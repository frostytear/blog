<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蓋索林 Gasolin</title>
  
  <subtitle>人們總是高估一年可以完成的事，卻低估十年能完成的事</subtitle>
  <link href="/feeds/posts/default.xml" rel="self"/>
  
  <link href="https://blog.gasolin.idv.tw/"/>
  <updated>2018-03-31T08:09:13.246Z</updated>
  <id>https://blog.gasolin.idv.tw/</id>
  
  <author>
    <name>gasolin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>做一個回覆食材營養成份的聊天機器人</title>
    <link href="https://blog.gasolin.idv.tw/2018/03/21/made-an-nutrition-bot/"/>
    <id>https://blog.gasolin.idv.tw/2018/03/21/made-an-nutrition-bot/</id>
    <published>2018-03-21T09:40:00.000Z</published>
    <updated>2018-03-31T08:09:13.246Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/nDA5cBml.jpg" alt="Imgur"></p><h2 id="食物-運動-與身體平衡">食物，運動，與身體平衡</h2><p>最近在看代謝型態飲食全書，裡面提到<code>吃下的東西</code>與<code>運動</code>，與體內的平衡和慢性病的產生有相當密切的關係。要讓身體重新回復到平衡的健康狀態，需要選擇適合自己的食物（營養素的比例）並搭配適當運動（有氧 + 無氧）與充足睡眠。</p><div class="mermaid">  graph LR食物 --> 身體吸收身體吸收 -- 影響 --> 體內系統的平衡運動 --> 強化身體強化身體 -- 影響 --> 體內系統的平衡睡眠 --> 修補身體修補身體 -- 影響 --> 體內系統的平衡</div><p>其中我們所選擇的一天三餐與餐間的<code>飲食習慣</code>，則是潛移默化地影響我們的健康。當我們持續吃不好的食物或錯誤的營養素比例，則讓體內的系統處在有的養分過多，有的養分不足的持續不平衡的狀態。這些不平衡讓各種體內各種系統無法正常工作。例如一餐吃進過多的精製糖份可能造成血液中的糖份快速升高，胰臟必須快速分泌大量胰島素來協助細胞消化糖份，當這樣不平衡的狀態維持久了，就會造成胰臟的過度負擔。當體內的代謝開始失常時，我們可以先觀察到一些亞健康症狀，累積久了就成了各種慢性病。因此<code>選擇適合自己的食物</code>是相當重要的。</p><div class="mermaid">  graph LR吃錯食物 --> 身體吸收身體吸收 -- 影響 --> 體內系統不平衡體內系統不平衡 --> 代謝失常代謝失常 --> 亞健康症狀亞健康症狀 --> 慢性病</div><h2 id="bot-怎麼做成的">Bot 怎麼做成的</h2><p>要<code>選擇適合自己的食物</code>時，我除了先做了測驗了解個人飲食中三大營養素(<code>碳水化合物</code>、<code>蛋白質</code>、<code>脂肪</code>)的參考比例，也想知道每樣吃下的東西大致的營養成份。</p><p>我想到如果有各種食材的營養成份資料，就可以做成聊天機器人或App以供隨時查詢。我搜尋了一下，發現政府資料開放平台上有公開的「<a href="https://data.gov.tw/dataset/8543" target="_blank" rel="noopener">食品營養成分資料集</a>」，提供csv, json, xml等格式下載。</p><p>下載開啟資料後，發現原始的JSON格式還是蠻…有趣的。</p><p>下載的JSON格式資料長這樣：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;食品分類&quot;:&quot;魚貝類&quot;&#125;,&#123;&quot;資料類別&quot;:&quot;樣品基本資料&quot;&#125;,&#123;&quot;整合編號&quot;:&quot;J11101&quot;&#125;,&#123;&quot;樣品名稱&quot;:&quot;鮸魚&quot;&#125;,&#123;&quot;俗名&quot;:&quot;鮸仔,敏魚,鮸,敏仔魚&quot;&#125;,&#123;&quot;樣品英文名稱&quot;:&quot;Brown croaker; Mi-iuy croaker&quot;&#125;</span><br></pre></td></tr></table></figure><p>…對於這種JSON存法只能呵呵。</p><p>重新下載了csv檔，這次總算正常了點。</p><p>解開後的csv檔案有接近50MB大小。寫了個腳本過濾掉不需要的資料，並轉換成需要的格式後，輸出總共不到500KB，就算放到App裡也還合適。</p><p>這次使用<a href="http://bottender.js.org/" target="_blank" rel="noopener">bottender</a>框架來連接到LINE。由於LINE需要HTTPS連線，開發的過程中使用了<a href="https://ngrok.com/" target="_blank" rel="noopener">ngrok</a>來讓LINE可以連到開發中的電腦，免去另外架設公開網站的麻煩。</p><p>此外還使用了<a href="http://fusejs.io/" target="_blank" rel="noopener">Fuse.js</a>這個模糊搜尋函式庫，在搜尋的時候只要打部份內容，就可以搜出相關的條目。</p><p>整個bot的軟體架構如下</p><div class="mermaid">  graph LRsubgraph 資料處理公開資料(csv) -- 轉換/過濾 --> JSONendsubgraph NodeJSON --> fuse.jsfuse.js --> bottenderbottender --> ngrok-cliendngrok-cli --> ngrokngrok --> ngrok-clingrok --> LINELINE --> ngrokngrok-cli --> bottender</div><h2 id="我可以加這個bot嗎">我可以加這個Bot嗎?</h2><p>目前雖然自用OK，但還沒做好公開的準備。有需求的歡迎留言。</p><h2 id="會不會-open-source">會不會 Open Source</h2><p>目前程式還沒有好好整理，尚不打算開源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/nDA5cBml.jpg&quot; alt=&quot;Imgur&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;食物-運動-與身體平衡&quot;&gt;食物，運動，與身體平衡&lt;/h2&gt;
&lt;p&gt;最近在看代謝型態飲食全書，裡面提到&lt;code&gt;吃下的東西&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="chatbot" scheme="https://blog.gasolin.idv.tw/tags/chatbot/"/>
    
  </entry>
  
  <entry>
    <title>Advanced tuning for my daily Elementary OS usage</title>
    <link href="https://blog.gasolin.idv.tw/2018/02/25/advanced_elementary_os_usage/"/>
    <id>https://blog.gasolin.idv.tw/2018/02/25/advanced_elementary_os_usage/</id>
    <published>2018-02-25T08:30:46.000Z</published>
    <updated>2018-03-31T08:09:13.242Z</updated>
    
    <content type="html"><![CDATA[<p>I’m a happy Elementary OS user and use it as my default desktop OS (~95%) several month. There are some useful tweakings that help me live with the Linux desktop.</p><h2 id="1-package-installer">1. Package installer</h2><p>Elementary OS does not provide deb installer by default, need install manually:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install gdebi</span><br><span class="line">sudo apt install software-properties-common</span><br></pre></td></tr></table></figure><p>And you can download <code>ubuntu software center</code> as well(optional).</p><h2 id="2-setup-fonts">2. Setup Fonts</h2><p>List system supported fonts</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fc</span>-list | cut -f2 -d: | sort -u</span><br></pre></td></tr></table></figure><p>Setup fonts</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.pantheon.terminal.settings font <span class="string">'Roboto Mono'</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface font-name <span class="string">'Open Sans 9'</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface document-font-name <span class="string">'Open Sans 10'</span></span><br></pre></td></tr></table></figure><h2 id="3-pairing-bluetooth-mouse">3. Pairing Bluetooth Mouse</h2><p>I can’t use GUI Bluetooth manager to pair with bluetooth device, but these commandline works well for me.</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ bluetoothctl</span><br><span class="line">$ agent on</span><br><span class="line">$ default-agent</span><br><span class="line">$ pairable on</span><br><span class="line">$ scan on</span><br><span class="line">$ devices (to see the devices and macs that you want to pair)</span><br><span class="line">$ pair &lt;dev mac&gt;</span><br><span class="line">$ trust &lt;dev mac&gt;</span><br><span class="line">$ connect &lt;dev mac&gt;</span><br></pre></td></tr></table></figure><h2 id="4-saving-power">4. Saving Power</h2><p><code>tlp</code> is a good tool for auto power management</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:linrunner/tlp</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install tlp</span><br><span class="line">sudo tlp start</span><br></pre></td></tr></table></figure><h2 id="5-auto-adjust-color-temperature">5. Auto adjust color temperature</h2><p><a href="http://jonls.dk/redshift/" target="_blank" rel="noopener">redshift</a> is by far the great f.lux like app for linux.</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install redshift redshift-gtk</span><br><span class="line">$ redshift-gtk</span><br></pre></td></tr></table></figure><p>Then configue it as auto start in task bar.</p><h3 id="6-touchpad-indicator">6. Touchpad indicator</h3><p>Sometimes you may found the cursor is moving to the wrong place. Install Touchpad indicator solved this issue.</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:atareao/atareao</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install touchpad-indicator</span><br></pre></td></tr></table></figure><p>and Toggle <code>Disable Touchpad on typing</code>.</p><h2 id="7-dropbox-icon">7. Dropbox icon</h2><p>Install Dropbox from its website, then <a href="http://sandeepbhardwaj.github.io/2016/11/13/missing-dropbox-icons-on-elementary-loki.html" target="_blank" rel="noopener">configue to fix the missing icon</a>.</p><h2 id="參考資料">參考資料</h2><ul><li>Tweaking fonts <a href="https://adam.merrifield.ca/2016/11/12/tweaking-fonts-in-elementary-os/" target="_blank" rel="noopener">https://adam.merrifield.ca/2016/11/12/tweaking-fonts-in-elementary-os/</a></li><li>Ubuntu 16.04 LTS: get bluetooth mouse to work <a href="https://askubuntu.com/questions/839014/ubuntu-16-04-lts-cant-get-bluetooth-mouse-to-work?rq=1" target="_blank" rel="noopener">https://askubuntu.com/questions/839014/ubuntu-16-04-lts-cant-get-bluetooth-mouse-to-work?rq=1</a></li><li><a href="http://refugeeks.com/use-tlp-to-optimize-the-power-consumption-in-ubuntu/" target="_blank" rel="noopener">http://refugeeks.com/use-tlp-to-optimize-the-power-consumption-in-ubuntu/</a></li><li><a href="https://elementaryos.stackexchange.com/questions/1090/how-to-optimize-elementary-os-for-maximal-battery-life-time-on-laptops" target="_blank" rel="noopener">https://elementaryos.stackexchange.com/questions/1090/how-to-optimize-elementary-os-for-maximal-battery-life-time-on-laptops</a></li><li><a href="https://itsfoss.com/night-shift-flux-ubuntu-linux/" target="_blank" rel="noopener">https://itsfoss.com/night-shift-flux-ubuntu-linux/</a></li><li>Top 10 Best Things To Do After Installing Elementary OS 0.4.1 Loki</li><li><a href="https://www.ubuntupit.com/top-10-best-things-installing-elementary-os/" target="_blank" rel="noopener">https://www.ubuntupit.com/top-10-best-things-installing-elementary-os/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I’m a happy Elementary OS user and use it as my default desktop OS (~95%) several month. There are some useful tweakings that help me liv
      
    
    </summary>
    
    
      <category term="linux" scheme="https://blog.gasolin.idv.tw/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Devtools的近期進展和新功能(2017)</title>
    <link href="https://blog.gasolin.idv.tw/2018/01/29/whats-new-in-devtools-2017/"/>
    <id>https://blog.gasolin.idv.tw/2018/01/29/whats-new-in-devtools-2017/</id>
    <published>2018-01-29T09:25:46.000Z</published>
    <updated>2018-03-31T08:09:13.250Z</updated>
    
    <content type="html"><![CDATA[<p>2017/9/22我和Ricky Chien在台灣第一次舉辦的<a href="https://twitter.com/hashtag/mozilladevtw2017?src=hash" target="_blank" rel="noopener">Mozilla Developer Conference</a>中，一起為大家介紹Firefox開發者工具, 也就是Devtools的近期進展和新功能<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>。</p><p>Devtools架構的大幅改進，是過去一年中所有Devtools貢獻者共同努力的成果。在這講題中，我們可以看到Devtools如何持續改進，並提供各種新的工具，讓開發網頁的過程變得更有效率。</p><p><img src="http://g.recordit.co/RN5AVhnpGX.gif" alt=""></p><p>透過在Firefox 57新版的統一選單介面上開啟Web Developer Tool，我們可以開啟Devtools的各種工具分頁分頁(Panel)。</p><p>Devtools簡單來說，就是各式各樣網頁開發者工具的集合。這些工具以一個個分頁（Panel）的形式組織在開發者工具區域中，我們稱這個區域為<code>Toolbox</code>，也就是<code>工具箱</code>。</p><h2 id="devtools-的過去">Devtools 的過去</h2><p>Devtools 的前身叫做 Firebug<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。在2006年時，Firefox 的創始者之一Joe Hewitt 寫出了Firebug這個Firefox 的網頁開發工具addon<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。使用者可以利用它除錯、編輯、刪改任何網站的CSS、HTML、DOM與JavaScript。也可以透過addon再次擴展它的功能。現在各家瀏覽器的網頁開發者工具都參考了Firebug功能。</p><p>過去的Web相關技術遠遠沒有今天成熟，Mozilla發明了一些特有的技術(XUL, XBL)來製作瀏覽器的介面與呼叫特殊的API(Addon API)來和作業系統互動。因為原有的addon架構無法支援FIrefox新的多執行緒(multiple process)架構，因此2016年Firebug開發團隊決定<strong>將Firebug直接整合進Devtools中</strong><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>，原有的Firebug開發團隊也大多加入了Firefox Devtools團隊繼續貢獻，也因此我和Ricky有了和原Firebug維護者Honza直接共事的機會，在過去半年中我們合作開發Network Monitor，透過Daily Meeting同步進度，也在合作的過程中得到許多難得的經驗。</p><h2 id="devtools-的現在">Devtools 的現在</h2><p>Devtools繼承Firebug的開發目標，也就是協助網頁開發者更有效率的製作網站。同時作為網頁開發者工具，我們希望開發者工具工具本身，也能用和網頁開發者使用的排版與框架來撰寫。</p><p>於是在Mozilla Web Summit，大家可以看到我們的成果。我們已經在使用HTML和Web Standard API來製作Devtools開發者工具！</p><p>使用HTML與Web Standard API只是第一步。我們進一步評估，選用了React和Redux作為前端UI介面與狀態管理框架。經過react改寫後，我們有了可在不同工具間中重用的元件庫。透過redux，每個工具也都有了清晰的App狀態管理機制。</p><p>我們將許多Devtools核心的專案放到Github上以方便開發者，並且將可以重用的元件，放到 <a href="https://github.com/devtools-html/devtools-core" target="_blank" rel="noopener">Devtools-Core</a> 專案中，將可以獨立運作的<a href="https://github.com/devtools-html/debugger.html" target="_blank" rel="noopener">Debugger.html</a>，<a href="https://github.com/devtools-html/perf.html" target="_blank" rel="noopener">Perf.html</a>專案也放到Github上，讓參與專案變得更容易。</p><p>如果想開發自己所需的的開發者工具。現在也可以使用Web Extension API來製作新的開發者工具面板。面板中也可以重用<code>Devtools-Core</code>專案提供的React介面元件，更快地打造自己的開發者工具。</p><h2 id="使用者介面的改進">使用者介面的改進</h2><p>Firefox 57上的 Devtools 分頁變得更美觀了。當然這些都已包成React component，喜歡還可以拿去用。</p><p>對於新配色的選擇，我們的UX團隊有做過可用性(Assessibility)測試<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>。即使是辨色有障礙的人，也可以容易地分辨不同色塊的差異。</p><h2 id="inspector-工具的改進">Inspector 工具的改進</h2><p>Inspector 工具是最常被使用的開發者工具。透過Inspector，可以查看或修改HTML。選到任一個Element時，可以查看並修改這個Element目前所有套用的Style。</p><p>透過重構Inspector，我們把原本使用的XUL與addon SDK替換為HTML和web API。並使用React + Redux來組織程式的內部架構。</p><p>在整理所有devtools新增功能的時候，我最先注意到的就是&quot;Find Useless Rules&quot;這個超實用的功能。</p><p>過去在Inspector裡只會在不合法的樣式旁顯示警告標誌，現在我們也會在「合法，但無用」的樣式旁也顯示警告標誌。比如在grid或flex layout中使用float屬性的話沒有作用，Inspector就會在float屬性旁顯示警告標誌。</p><p>此外，Inspector的Box Model會列出所有影響的這個元件位置，大小，或形狀的屬性。透過新的box model介面，可以更容易地查看並調整上下左右position參數，快速地將版面調整到理想狀態。</p><p>Firefox Devtools 也是最先支援 Grid Layout <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>的開發者工具。我們可以看到，在Rules side panel中的任何修改，都會直接反映到頁面上。</p><p>在Layout Side panel上會列出了頁面上所有的Grid Layout。右側則可以選擇要顯示輔助線號碼，區塊名稱，或是要不要延長Grid格線以便排版。</p><iframe width="560" height="315" src="https://www.youtube.com/embed/EinJPX86XCE?rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><p>不僅如此，在畫面上也可以見到，開發者也可以在 Layout Side panel中快速的查看對應的網格。我們可以透過這些選項更好地查看頁面上的Grid Layout。</p><h2 id="ｗeb-console">Ｗeb Console</h2><p>Web Console應該是Javascript開發者最常用的網頁工具吧。除了查看頁面上的Javascript錯誤，印log外，Web Console可以即時執行javascript，或是存取頁面上的 Ｇlobal Object。</p><p>去年Web Console也經過改寫。使用React + Redux來組織程式的內部架構。</p><p>我們在console中可以即時執行javascript並取得執行結果。不管是哪種類型的變數，無論是boolean, array, object 都會用Object logs來顯示。</p><p>在rewrite web console的過程中，我們也將Object logs包裝起來變成一個可以重用的React Component。</p><p>這個元件被大量地運用在Debugger, Network等其他panel上。</p><p>如果你想要開發自己的開發者工具或剛好需要類似的元件，reps可以在github上找到。或是透過<code>npm install devtools-reps</code>命令來安裝到你的專案中。</p><p><a href="https://github.com/devtools-html/devtools-core/tree/master/packages/devtools-reps#readme" target="_blank" rel="noopener">https://github.com/devtools-html/devtools-core/tree/master/packages/devtools-reps#readme</a></p><p>Web console 近期也透過tree和reps元件，支援了console group功能 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/group" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Console/group</a></p><p><img src="http://g.recordit.co/NuO10hu9Ug.gif" alt=""></p><p>現在透過web console實驗XMLHTTPRequest 或 fetch 時，也可以透過HTTP inspector來即時查看http request的內容。整套HTTP inspector元件是來自Network Monitor，只經過一點點修改就能完整套用。因此在 web console 中可以直接看到與在network panel中一樣的資訊，非常方便。</p><p><img src="http://g.recordit.co/ebfs76lmG1.gif" alt=""></p><h2 id="perf-html-網頁效能監測工具">Perf.html 網頁效能監測工具</h2><p>最後我想介紹的是 Perf.html 這套工具。</p><p>要提升網頁的效能是相當考驗技術的。透過profiling，也就是量測的結果，我們可以更直觀地找出網頁效能的瓶頸並做出針對性地改善。perf.html就是這樣的量測工具。</p><p>去年perf.html也經過改寫。使用React + Redux來組織程式的內部架構。有自己的網頁，可以脫離devtools獨立運作。程式碼host在github上。</p><p>perf.html使用前需先到網站上安裝addon，在要量測前後按下start/stop，就可以得到量測的profile。</p><p>perf.html最棒的點是，量測好的profile可以透過addon直接上傳到網站上，我們是在一般網站的介面上查看量測的結果。可以直接分享這個網址，或是標註出關注的時間區間後分享。和其他人一起trace效能瓶頸。</p><p>經過photon更新後，perf.html介面風格將變得更加簡潔，配色變得更大膽，用起來更舒服。</p><p>以上是我分享的部分。若您對Devtools感興趣，可以到<a href="http://firefox-dev.tools/" target="_blank" rel="noopener">firefox-dev.tools</a>網站查看所有與 Firefox Devtools 相關的資訊。</p><h2 id="參考資料">參考資料</h2><ul><li>[1] Firebug <a href="http://www.drdobbs.com/tools/ajax-debugging-with-firebug/196802787" target="_blank" rel="noopener">http://www.drdobbs.com/tools/ajax-debugging-with-firebug/196802787</a></li><li>[2] <a href="https://medium.com/mozilla-tech/a-quick-history-of-firefox-devtools-620d3074b510" target="_blank" rel="noopener">https://medium.com/mozilla-tech/a-quick-history-of-firefox-devtools-620d3074b510</a></li><li>[3] Firebug lives on Firefox Devtools <a href="https://hacks.mozilla.org/2016/12/firebug-lives-on-in-firefox-devtools/" target="_blank" rel="noopener">https://hacks.mozilla.org/2016/12/firebug-lives-on-in-firefox-devtools/</a></li><li>[4] Grid Layout <a href="https://hacks.mozilla.org/2017/06/new-css-grid-layout-panel-in-firefox-nightly/" target="_blank" rel="noopener">https://hacks.mozilla.org/2017/06/new-css-grid-layout-panel-in-firefox-nightly/</a></li><li>[5] colors with accessible contrast in concern <a href="https://blog.nightly.mozilla.org/2017/09/11/developer-tools-visual-refresh-coming-to-nightly/" target="_blank" rel="noopener">https://blog.nightly.mozilla.org/2017/09/11/developer-tools-visual-refresh-coming-to-nightly/</a></li><li>[6] Devtools Photon UI <a href="https://hacks.mozilla.org/2017/09/developer-edition-devtools-update-now-with-photon-ui/" target="_blank" rel="noopener">https://hacks.mozilla.org/2017/09/developer-edition-devtools-update-now-with-photon-ui/</a></li><li>[7] 簡報檔位於<a href="https://docs.google.com/presentation/d/1mUoXy97Uv4FqkTiPBqMAw5AlgRz3VCrHpzShS1bl9Jc/edit?usp=sharing" target="_blank" rel="noopener">Google Doc</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017/9/22我和Ricky Chien在台灣第一次舉辦的&lt;a href=&quot;https://twitter.com/hashtag/mozilladevtw2017?src=hash&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mozilla Dev
      
    
    </summary>
    
    
      <category term="web" scheme="https://blog.gasolin.idv.tw/tags/web/"/>
    
      <category term="devtools" scheme="https://blog.gasolin.idv.tw/tags/devtools/"/>
    
  </entry>
  
  <entry>
    <title>用gitbook寫書的體驗</title>
    <link href="https://blog.gasolin.idv.tw/2018/01/28/white-a-gitbook/"/>
    <id>https://blog.gasolin.idv.tw/2018/01/28/white-a-gitbook/</id>
    <published>2018-01-28T05:30:30.000Z</published>
    <updated>2018-03-31T08:09:13.250Z</updated>
    
    <content type="html"><![CDATA[<p>把過去半年本部落格上關於區塊鏈的文章整理放到Gitbook。命名為<a href="https://www.gitbook.com/book/gasolin/learn-ethereum-dapp/details" target="_blank" rel="noopener">Ethereum區塊鏈！智能合約(Smart Contract)與分散式網頁應用(DApp)入門</a>，對區塊鏈，智能合約，分散式應用(DApp)感興趣的讀者不妨前往一觀。</p><p>這不是我寫的第一本書<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，也不是我第一本用Markdown寫的電子書(以前用Leanpub出版過<a href="https://leanpub.com/gaiafromabove" target="_blank" rel="noopener">Firefox OS 開發書</a>)，但絕對是我編輯過程最順暢的一本書（雖然還未完成 XD）。</p><h2 id="一路markdown">一路Markdown</h2><p>編輯過程最順暢不是因為對主題很熟悉或寫得快，而是因為從部落格文章初稿到Gitbook，在寫作的過程中可以一路使用Markdown。而且由於原本部落格圖片皆使用外連，因此引用圖片時也不用像以前編書時需要重新導入的過程。由於gitbook也支援<code>mermaid.js</code>插件，支援我常常使用的flowchart語法，因此這些流程圖也不需要重新截圖或繪製，節省了大量時間。</p><h2 id="所見即所得編輯器">所見即所得編輯器…</h2><p>我已有Ｍarkdown格式的初稿，但剛開始我使用gitbook提供的所見即所得的編輯器。使用起來感覺非常不自在。</p><p>線上編輯器提供的<code>new change request</code>，所見即所得編輯等功能，特別是gitbook提供的所見即所得編輯器無法切換回純Markdown模式，對於已熟悉git, Markdown語法的我來說並沒有變得好用。直接將Markdown格式貼到編輯器上時，也無法順利辨識格式，反而是貼上已輸出的部落格網頁時效果好很多。</p><p>所以最後我放棄使用線上編輯器，而是在本機編輯Markdown後直接git推送到專案上。</p><p>gitbook在同步收到新的改動後，會自動編譯並發布新版本，相當方便。接下來應該會繼續使用這個流程。</p><h2 id="參考資料">參考資料</h2><ul><li>[1] 我的著作 <a href="https://gasolin.idv.tw/portfolio#books" target="_blank" rel="noopener">https://gasolin.idv.tw/portfolio#books</a></li><li>[2] 利用gitbook命令行工具创建和编译书籍 <a href="http://mdengli.com/gitbook_cmd_study/" target="_blank" rel="noopener">http://mdengli.com/gitbook_cmd_study/</a></li><li>[3] 深入淺出 GitBook 寫作與自助出版，電子書也能多人協作 <a href="http://www.codedata.com.tw/social-coding/gitbook-self-publishing" target="_blank" rel="noopener">http://www.codedata.com.tw/social-coding/gitbook-self-publishing</a></li><li>[4] 用 GitBook 來寫本書吧！<a href="http://www.oxxostudio.tw/articles/201502/gitbook.html" target="_blank" rel="noopener">http://www.oxxostudio.tw/articles/201502/gitbook.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把過去半年本部落格上關於區塊鏈的文章整理放到Gitbook。命名為&lt;a href=&quot;https://www.gitbook.com/book/gasolin/learn-ethereum-dapp/details&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
    
      <category term="ethereum" scheme="https://blog.gasolin.idv.tw/tags/ethereum/"/>
    
      <category term="git" scheme="https://blog.gasolin.idv.tw/tags/git/"/>
    
      <category term="markdown" scheme="https://blog.gasolin.idv.tw/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>我如何做個人自動化紀錄-2018版</title>
    <link href="https://blog.gasolin.idv.tw/2018/01/26/personal-automation-in-2018/"/>
    <id>https://blog.gasolin.idv.tw/2018/01/26/personal-automation-in-2018/</id>
    <published>2018-01-26T01:57:29.000Z</published>
    <updated>2018-03-31T08:09:13.246Z</updated>
    
    <content type="html"><![CDATA[<p>2017年開始紀錄自己使用的自動化紀錄工具，今年更新。</p><h2 id="為什麼要做個人自動化紀錄">為什麼要做個人自動化紀錄?</h2><p>有人會問，Facebook/Twitter不就可以記錄大小事了嗎? 如果會這麼回答，那就實在太天真了😏。FB上也許包含了自己覺得值得分享的事，但生活中還有諸多事情值得記錄，而不適合與大眾分享。擁有自己的一份完整數位化生活記錄，是我持續的個人目標之一。要達成這個目標，需要藉助一些自動化紀錄工具，好讓整個過程變得自然而不困難。</p><h2 id="照片自動化備份-📷">照片自動化備份 📷</h2><ul><li>360CAM所拍的相片一律備份到手機</li><li><a href="http://www.dropbox.com/" target="_blank" rel="noopener">Dropbox</a>, 自動從手機上傳照片</li><li>Google相簿, 充電時自動從手機備份照片到Google雲端</li><li>NAS (Synnalogy), 透過<code>Cloud Sync</code>從Dropbox同步照片。</li></ul><div class="mermaid">  graph LRcam[360 CAM]User -- take photo --> camUser -- take photo --> Phonecam --> PhonePhone -.-> DropboxPhone -.-> gphoto[Google Photo]Dropbox -.-> NAS</div><h2 id="運動自動化紀錄-🚶">運動自動化紀錄 🚶</h2><ul><li><s>記步，睡眠紀錄：小米手環2</s></li><li>體重：小米體重計</li></ul><div class="mermaid">  graph LRUser -- 量體重 --> 小米體重計小米體重計 -.-> 小米運動App</div><p>現已不再帶小米手環2，覺得記錄睡眠與步數，並無法改善健康狀況，意義不大。同時為了降低多走路所需要的意志力，把每日步數改成更容易達成的300步，只要開始走，通常都會超過需要的步數。</p><hr><h2 id="生活事件自動化紀錄">生活事件自動化紀錄</h2><p>延續<a href="https://blog.gasolin.idv.tw/2015/02/28/%E7%94%A8-IFTTT-%E5%81%9A%E8%87%AA%E5%8B%95%E7%94%9F%E6%B4%BB%E7%B4%80%E9%8C%84-LifeLog/">用 IFTTT 做自動生活紀錄</a>這篇的思路，我把看過的書籍、電影，喜歡的Youtube影片，貼過的文章,每日完成的事項都記錄到Google日曆中，以方便之後回顧。</p><h3 id="自動閱讀-觀看紀錄-📚">自動閱讀/觀看紀錄 📚</h3><p>對於書籍與電影, 我使用RSS + IFTTT + Google Calendar來自動紀錄。當我在豆瓣上修改狀態，豆瓣的RSS也跟著改變，這時IFTTT會將RSS中的新事項紀錄到Google 日曆上。對於Youtube上like的影片，Facebook或Twitter上新貼的文章，也會透過IFTTT紀錄到Google 日曆上。</p><div class="mermaid">  graph LRUser -- add movie --> DoubanUser -- post --> BlogBlog -.-> RSSDouban -.-> RSSRSS -.-> IFTTTIFTTT -.-> gcal[Google Calendar]</div><p>透過RSS轉IFTTT紀錄</p><div class="mermaid">  graph LRUser -- like --> YoutubeUser -- post --> FacebookUser -- post --> TwitterYoutube -.-> IFTTTFacebook -.-> IFTTTTwitter -.-> IFTTTIFTTT -.-> gcal[Google Calendar]</div><p>直接透過IFTTT紀錄</p><h3 id="自動紀錄每日完成的事項-📓">自動紀錄每日完成的事項 📓</h3><p>這部份是自動紀錄的核心。使用 Todoist + IFTTT + Google Calendar 即可達成。我在Google Calendar上使用一個單獨的日曆(成功日記)來紀錄每日完成的事項。</p><div class="mermaid">  graph LRUser -- checked --> TodoistTodoist -.-> IFTTTIFTTT -.-> gcal[Google Calendar]</div><p>If task completed in Todoist, Then log into Google Calendar</p><h4 id="從email新增待辦事項-✉">從Email新增待辦事項 ✉️</h4><p>為了更方便地蒐集待辦事項，我參考這份影片 <a href="https://youtu.be/V7Dk7pzjJmM?t=11m30s" target="_blank" rel="noopener">https://youtu.be/V7Dk7pzjJmM?t=11m30s</a> 來將Todoist#Inbox設定為Email聯絡人，這樣處理Email的過程中也能快速地新增待辦事項。</p><p>事實上這設定很少使用。</p><h3 id="紀錄看過或待看的網頁-🌐">紀錄看過或待看的網頁 🌐</h3><p>我會將待看的文章搜集到Pocket。</p><p>除了瀏覽Facebook或Twitter上的文章，我也使用Feedly訂閱一些自己挑選過的網站。並將Feedly設定成當我做標記時，就將本篇文章轉存到Pocket稍候閱讀列表，我可以掃過Feedly列表，標記感興趣的新聞，稍後再到Pocket閱讀。</p><p>這樣讓我在看到文章連結當下不需急著看完整篇文章，而是在有空閒的時候才閱讀這些文章。</p><p>我唯一的待辦事項收件夾是Todoist，若看到值得閱讀(紀錄)的網頁，桌面上我使用瀏覽器的<code>Pocket</code>外掛插件(Firefox瀏覽器內建)，將待看網頁記錄到Pocket中。</p><p>若這個網頁非看不可，我會在按下插件時填入一個自訂標籤<code>fox</code>，然後透過IFTTT，若發現Pocket中新增了一筆含<code>fox</code>標籤的網頁，就新建一筆Todoist代辦事項。</p><p>在手機上就直接使用Todoist和Pocket等App達到一樣的效果。</p><div class="mermaid">  graph LRFeedly --> PocketBrowser --> addon[Pocket addon + tag]addon --> Pocketpocket -.-> IFTTTIFTTT -.-> Todoist</div><h3 id="文章更新時自動提醒">文章更新時自動提醒 ⏰</h3><p>有些網站並未提供RSS訂閱，手機上我會使用<a href="https://play.google.com/store/apps/details?id=me.webalert" target="_blank" rel="noopener">Web Alert</a>來取得網頁更新提醒。</p><div class="mermaid">  graph LRwebalert[Web Alert] --> UserUser --> Browser</div>¨¨<h3 id="開發工具設定自動備份">開發工具設定自動備份¨</h3><p>使用VS Code <a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync" target="_blank" rel="noopener">Settings Sync</a> ，只需剛開始時設定一次，之後可同步各種VS Code中的設定與插件。</p><h3 id="半自動工作紀錄-💼">半自動工作紀錄 💼</h3><p>透過翻看Todoist或Google Calendar，我可以輕易地將過去一週達成的事項整理出來，再送PR到Github上。也可以說這塊目前只能算半自動化地列出過去事項列表，可以再繼續改進。</p><hr><h2 id="自動化網站部署-🌐">自動化網站部署 🌐</h2><p>目前已使用Github來放我的個人網站與部落格，透過與Travis CI整合，我所修改的任何內容，在幾分鐘之內都會自動部署到網站上。</p><p>如何做可參考 <a href="https://blog.gasolin.idv.tw/2016/09/18/hello-world/">Hello Hexo</a> (個人網站自動化部署) 和 <a href="https://blog.gasolin.idv.tw/2017/01/03/ghpage-auto-deploy/">Automatically deploy new commit to github pages via Travis CI</a></p><div class="mermaid">  graph LRmaster[Github:master]travis[Travis CI]ghpages[Github:gh-pages]User -- commit --> mastermaster -. auto build .-> travistravis -.  auto deploy .-> ghpages</div><p>Auto website deploy flow</p><p>一些可以直接運作在瀏覽器的專案(如BlocklyDuino和Saihubot)，我會直接將gh-pages設為預設分支，所有改動直接push到這分支中。這樣一有改動即可在網頁上看到更新成果。</p><h2 id="定期整理">定期整理</h2><p>撰寫本文的目的之一，也是讓我有回顧我的自動化運作的機會。</p><h3 id="照片備份規則">照片備份規則</h3><p>由於Dropbox空間有限，會不定期將Dropbox上的照片移動到到NAS上按年月份分類的<code>photo/</code>資料夾.</p><p>我的照片並不算多，但若有出遊的月份通常照片會暴增。所以我的基本備份規則是依年份，並以雙月份命名資料夾,若是當月有重大活動則直接在檔名中標注。例如2016年的照片資料夾裡會有<code>2016_10_11</code>，或是<code>2016_06_london</code>這樣的命名。</p><p>在整理照片的時候，每當遇到特別喜歡的，我會另存到Dropbox中的一個依年份歸檔的資料夾，例如2017年的精彩照片我會另存到 <code>dropbox/spot/2017</code>資料夾中，這樣隨時可以找出來欣賞。</p><p>另外每年累積的一些螢幕截圖，也放在當年度的<code>screenshots</code>資料夾裡。</p><h3 id="清理rss-feed">清理RSS Feed</h3><p>透過Feedly訂閱RSS Feed太容易，但是不小心每天收到的新聞量就遠高於自己能吸收的量，這時可以到<a href="https://feedly.com/i/organize/my" target="_blank" rel="noopener">https://feedly.com/i/organize/my</a> 把那些失效的連結清掉，並快速檢視一下現在仍在訂閱的網站，是否還對這些主題感興趣。</p><h2 id="參考資料">參考資料</h2><ul><li><a href="https://blog.gasolin.idv.tw/2017/02/02/personal-automation-in-2017/">我如何做個人自動化紀錄-2017版</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017年開始紀錄自己使用的自動化紀錄工具，今年更新。&lt;/p&gt;
&lt;h2 id=&quot;為什麼要做個人自動化紀錄&quot;&gt;為什麼要做個人自動化紀錄?&lt;/h2&gt;
&lt;p&gt;有人會問，Facebook/Twitter不就可以記錄大小事了嗎? 如果會這麼回答，那就實在太天真了😏。FB上也許包含了
      
    
    </summary>
    
    
      <category term="web" scheme="https://blog.gasolin.idv.tw/tags/web/"/>
    
      <category term="mobile" scheme="https://blog.gasolin.idv.tw/tags/mobile/"/>
    
      <category term="life" scheme="https://blog.gasolin.idv.tw/tags/life/"/>
    
      <category term="automation" scheme="https://blog.gasolin.idv.tw/tags/automation/"/>
    
  </entry>
  
  <entry>
    <title>個人工具箱2018二月</title>
    <link href="https://blog.gasolin.idv.tw/2018/01/25/tooling-in-2018-feb/"/>
    <id>https://blog.gasolin.idv.tw/2018/01/25/tooling-in-2018-feb/</id>
    <published>2018-01-25T07:23:00.000Z</published>
    <updated>2018-03-31T08:09:13.246Z</updated>
    
    <content type="html"><![CDATA[<p><code>先記錄下來手邊使用的工具，才有機會從繁雜中歸納出簡單的使用規則。</code></p><p>2011<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>年時紀錄了一次當時的個人工具箱，2016年開始再次紀錄自己手邊工具箱的改變<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>🤹。今年初工作上有了變化，也將家中的環境包含進配置列表中。</p><h2 id="主要裝備">主要裝備</h2><ul><li>💻Dell XPS 13 (8550), Windows 10, i7 4GHz x4, 8GB RAM, 13.3&quot; LCD，作業系統：<a href="https://blog.gasolin.idv.tw/2017/10/25/xps13-elementary-os/">Elementary OS + Windows</a></li><li>📱<a href="https://oneplus.net/global/3" target="_blank" rel="noopener">One Plus 3</a>, Android, 6GB RAM, 5.5&quot; AMOLED</li><li>🎧Sony WI-1000 降噪耳機</li></ul><h3 id="家">家</h3><ul><li>🖥24&quot; LCD</li><li>⌨️羅技K375s鍵盤</li><li>🖱羅技M720滑鼠</li><li>📦Synology NAS: 電影，影集，照片，資料備份</li><li>💡Yeelight LED燈泡</li><li>備用 💻Macbook Air 13&quot;, 2012年版</li><li>備用 📺Chromecast 一代</li><li>備用 🔈Echodot</li><li>備用 Respberry Pi 3</li><li>備用 📙Kindle Voyage</li></ul><h3 id="和去年相比的改變：">和去年相比的改變：</h3><p>主力用💻Dell XPS 13&quot;，家中添購了一台🖥24&quot; LCD接筆電，搭配3轉1 HDMI Hub，接🎮Nintendo Switch, Chromecast, Respberry Pi，可滿足影音相關需求。HDMI設備通電時會自動切換到對應的設備。</p><div class="mermaid">  graph LRLCD -- DVI --- NotebookLCD -- HDMI --- hub{HDMI Hub}hub --- ns[Nintendo Switch]hub --- Chromecasthub --- rpi[Respberry Pi]</div><p>上次記錄前即開始使用的⌨️羅技K375s鍵盤與🖱羅技M720滑鼠，兩者特點都是同時支援使用USB或藍牙控制設備，讓我可以用一套鍵鼠控制多種設備。</p><h3 id="🕸網站工具">🕸網站工具</h3><ul><li>🕸主要瀏覽器：<a href="https://www.mozilla.org/en-US/firefox/products/" target="_blank" rel="noopener">Firefox</a></li><li>瀏覽器插件<ul><li>顏文字查詢：Emoji cheatsheet</li><li>翻譯：ImTranslator</li><li>拼字訂正：Grammarly</li><li>密碼管理：Bitwarden</li></ul></li><li>瀏覽器常駐分頁<ul><li>✉️<a href="http://mail.google.com/" target="_blank" rel="noopener">GMail</a>, Inbox</li><li>📆<a href="http://www.google.com/calendar" target="_blank" rel="noopener">Google日曆</a></li><li>📒記帳: <a href="https://toshl.com" target="_blank" rel="noopener">Toshl</a> (付費)</li><li>✅待辦事項：<a href="https://todoist.com/" target="_blank" rel="noopener">Todoist</a> (付費)</li></ul></li><li>👥主要社交網站：<a href="http://www.facebook.com/" target="_blank" rel="noopener">Facebook</a>、<a href="https://twitter.com/gasolin" target="_blank" rel="noopener">Twitter</a></li><li>📝記事：<a href="http://keep.google.com/" target="_blank" rel="noopener">Google keep</a>, Google Doc</li><li>💾網路硬碟：<a href="http://www.dropbox.com/" target="_blank" rel="noopener">Dropbox</a>, 主要用作同步照片</li><li>🔑密碼管理：<a href="https://www.bitwarden.com/" target="_blank" rel="noopener">Bitwarden</a></li><li>📰新聞聚合：<a href="https://feedly.com/" target="_blank" rel="noopener">Feedly</a></li><li>📘閱讀紀錄：<a href="https://share.readmoo.com/mooer/lifaicqb9/bookshelf/gasolin/read" target="_blank" rel="noopener">Readmoo分享書</a></li><li>🎥看電影記錄：<a href="http://www.douban.com/" target="_blank" rel="noopener">豆瓣</a></li><li>🗂個人網站：<a href="http://www.gasolin.idv.tw" target="_blank" rel="noopener">個人網站</a>, <a href="https://github.com/gasolin/blog/" target="_blank" rel="noopener">Github</a></li><li>🗂個人履歷：<a href="https://www.linkedin.com/in/fredglin/" target="_blank" rel="noopener">Linkedin</a></li><li>🔗IFTTT <a href="https://blog.gasolin.idv.tw/2018/01/26/personal-automation-in-2018/">自動化生活紀錄2018</a></li><li>📺<a href="https://www.youtube.com/" target="_blank" rel="noopener">Youtube</a></li><li>👛電子錢包<a href="https://www.myetherwallet.com/" target="_blank" rel="noopener">MyEtherWallet</a>, <a href="https://blog.gasolin.idv.tw/2017/12/26/setup_ledger_nano_on_linux/">Ledger Nano S</a></li></ul><h3 id="設計工具">設計工具</h3><ul><li>Mockup：<a href="http://www.balsamiq.com/products/mockups" target="_blank" rel="noopener">Balsmiq Mockups</a></li><li>螢幕動畫錄製： <a href="https://github.com/phw/peek" target="_blank" rel="noopener">Peek</a>(Linux), <a href="http://www.recordit.co/" target="_blank" rel="noopener">Recordit</a>(Mac)</li><li>心智圖：XMind</li></ul><h3 id="開發工具">開發工具</h3><ul><li>編輯器：VS Code<ul><li>Blank Line at the End</li><li>Diff Tool</li><li>EditorConfig for VSCode</li><li>Go</li><li>Guides: more guide line</li><li>GitLens: more git info</li><li>Python</li><li>Settings Sync</li><li>solidity</li><li>Trailing Spaces</li></ul></li><li>版本控制：git</li><li>套件管理：apt (Linux), <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>, yarn, Chocolatey(windows)</li></ul><p>若需要在Windows上開發，能用Chocolatey處理的就用Chocolatey處理。</p><h3 id="娛樂工具">娛樂工具</h3><ul><li>🎮Nintendo Switch</li><li>📺Chromecast (少用)</li><li>🎮Steam / vlc (少用)</li></ul><p>因為攜帶便利，現在主要只玩NS上的遊戲。Steam上看到喜歡的遊戲，也盡量等NS上出了再買。</p><h2 id="📱android-手機應用">📱Android 手機應用</h2><ul><li>瀏覽器：Firefox for Android</li><li>網頁更新通知：Web Alert</li><li>閱讀：Feedly, Readmoo</li><li>稍候閱讀：Pocket</li><li>信箱：Inbox, Gmail</li><li>地圖：Google地圖</li><li>記事：Keep</li><li>內建相機, 內建時鐘</li><li>相簿：內建相簿, Google相簿, Dropbox</li><li>社交：Facebook, LINE, Twitter</li><li>待辦事項：<a href="https://play.google.com/store/apps/details?id=com.todoist" target="_blank" rel="noopener">Todoist</a></li><li>密碼管理：Bitwarden</li><li>記帳: <a href="https://play.google.com/store/apps/details?id=com.thirdframestudios.android.expensoor" target="_blank" rel="noopener">Toshl</a></li><li>線上影片：Youtube</li><li>有聲書：Audible</li><li>音樂：豆瓣FM</li><li>健康：小米運動, Pokemon Go, 7Min workout</li></ul><p>工具</p><ul><li>2步驟認證：Duo Mobile</li><li>旅遊：Google翻譯, TripAdvisor</li><li>影片播放：MX Player, DS video</li><li>記錄看書狀況：Readmoo分享書</li><li>線上學習：Udemy, <a href="http://EggHead.io" target="_blank" rel="noopener">EggHead.io</a></li><li>IFTTT</li><li>💳街口支付</li></ul><h2 id="reference">Reference</h2><ul><li><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> <a href="https://blog.gasolin.idv.tw/2013/01/02/%E5%80%8B%E4%BA%BA%E5%B7%A5%E5%85%B7%E7%AE%B12011/">個人工具箱2011</a></li><li><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> <a href="https://blog.gasolin.idv.tw/2016/12/19/tooling-in-2016/">個人工具箱2016</a></li><li><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> <a href="https://blog.gasolin.idv.tw/2017/02/02/tooling-in-2017/">個人工具箱2017</a></li><li><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> <a href="https://blog.gasolin.idv.tw/2017/02/02/tooling-in-2017-sep/">個人工具箱2017九月</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;先記錄下來手邊使用的工具，才有機會從繁雜中歸納出簡單的使用規則。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2011&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;年時紀錄了一次當時的個人工具箱，2016
      
    
    </summary>
    
    
      <category term="life" scheme="https://blog.gasolin.idv.tw/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>如何撰寫智能合約(Smart Contract)?(IV)加入單元測試</title>
    <link href="https://blog.gasolin.idv.tw/2018/01/02/howto-write-a-contract-test/"/>
    <id>https://blog.gasolin.idv.tw/2018/01/02/howto-write-a-contract-test/</id>
    <published>2018-01-02T07:00:05.000Z</published>
    <updated>2018-03-31T08:09:13.246Z</updated>
    
    <content type="html"><![CDATA[<p>因為智能合約一旦部署就難以修改，因此合約的安全性極其重要，要避免合約中出現一些基礎錯誤，除了透過第三方驗證外，完整地單元測試(unit test)也是必需的。</p><p>目前最成熟的智能合約單元測試方式，還是透過<code>Truffle</code>開發框架來達成。有趣的是Truffle主要使用Javascript來撰寫智能合約的單元測試（也可以用 solidity來寫）。</p><h2 id="加入測試">加入測試</h2><p>接續上一篇建立的<code>HelloToken</code>合約，在<code>test/</code>目錄下加入<code>test_hello_token.js</code>測試檔案（如果覺得這份程式碼不易理解，可跳過這節，後面會介紹更簡潔的測試方法，到時再回來對照著看）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloToken = artifacts.require(<span class="string">'HelloToken'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INITIAL_SUPPLY = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">let</span> _totalSupply;</span><br><span class="line"></span><br><span class="line">contract(<span class="string">'HelloToken'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">accounts</span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should met initial supply'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> contract;</span><br><span class="line">    HelloToken.deployed().then(<span class="function">(<span class="params">instance</span>) =&gt;</span> &#123;</span><br><span class="line">        contract = instance;</span><br><span class="line">        <span class="keyword">return</span> contract.totalSupply.call();</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">totalSupply</span>) =&gt;</span> &#123;</span><br><span class="line">        _totalSupply = totalSupply;</span><br><span class="line">        assert.equal(totalSupply.toNumber(), INITIAL_SUPPLY);</span><br><span class="line">        <span class="keyword">return</span> contract.balanceOf(accounts[<span class="number">0</span>]);</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">senderBalance</span>) =&gt;</span> &#123;</span><br><span class="line">        assert.equal(_totalSupply.toNumber(), senderBalance.toNumber());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>運行<code>truffle test</code>可看到測試通過的結果。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Contract: HelloToken</span><br><span class="line">    ✓ should met initial supply</span><br><span class="line"></span><br><span class="line">1 passing (11ms)</span><br></pre></td></tr></table></figure><h3 id="講解">講解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloToken = artifacts.require(<span class="string">'HelloToken'</span>);</span><br></pre></td></tr></table></figure><p><code>artifacts.require</code>的用法和在<code>migrations/</code>中的用法相同，可以直接引入對應的智能合約。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract(<span class="string">'HelloToken'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">accounts</span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should met initial supply'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Truffle是使用Javascript開發中常見的<a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a>測試框架和<a href="http://chaijs.com/" target="_blank" rel="noopener">Chai</a>斷言庫來做單元測試。差別只是把Mocha test中的 <code>describe</code>換成<code>contract</code>。根據官方文件<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，<code>contact</code>執行前會自動重新部署到testrpc(或測試網路)上，所以智能合約會是剛部署好乾淨的狀態。</p><p>此外，<code>contract</code>也會帶入<code>accounts</code>變數，裡面儲存了testrpc或其他你運行的測試網路所提供的帳號，開發者可以直接使用這些帳號來測試合約。</p><p>第一個測試是來測部署合約後預設的代幣數目是否正確。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> contract;</span><br><span class="line">HelloToken.deployed().then(<span class="function">(<span class="params">instance</span>) =&gt;</span> &#123;</span><br><span class="line">    contract = instance;</span><br><span class="line">    <span class="keyword">return</span> contract.totalSupply.call();</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">totalSupply</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>這邊內容和在<code>truffle console</code>中輸入的測試內容雷同，使用<code>Promise</code>來確定每個非同步的操作都在上一個操作完成後才繼續執行。</p><p>上一個操作可以透過 <code>return</code> 語句回傳下個操作需要的參數。例如這邊<code>then</code>裡面傳入的<code>totalSupply</code>參數，是來自上一行<code>return contract.totalSupply.call()</code>的結果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assert.equal(totalSupply.toNumber(), INITIAL_SUPPLY);</span><br><span class="line">...</span><br><span class="line">assert.equal(_totalSupply.toNumber(), senderBalance.toNumber());</span><br></pre></td></tr></table></figure><p>這邊我們透過<code>assert.equal</code>語句驗證了<code>HelloToken</code>合約中的初始代幣總額與<code>INITIAL_SUPPLY</code>參數的值相符，且與合約部署者(<code>accounts[0]</code>)帳戶中擁有的總額相符。</p><h2 id="使用-async-await-簡化測試">使用 async/await 簡化測試</h2><p>要理解這樣的promise chain需要一些練習。但其實上面的測試用例中，我們只想做好最後的兩個assert驗證。有沒有比較直覺的測試方法呢？</p><p>有的！2017下半年，Javascript 語言支援了<code>async/await</code>語句[2]（只要安裝Node 7.6版以上即可使用），可以用更直覺的方式撰寫非同步的程式碼。</p><p>智能合約測試剛好也使用大量的非同步程式碼。使用<code>async/await</code>語句改寫後的智能合約測試程式碼如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloToken = artifacts.require(<span class="string">'HelloToken'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INITIAL_SUPPLY = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">contract(<span class="string">'HelloToken'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">accounts</span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should met initial supply'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> contract = <span class="keyword">await</span> HelloToken.deployed();</span><br><span class="line">    <span class="keyword">let</span> totalSupply = <span class="keyword">await</span> contract.totalSupply.call();</span><br><span class="line">    <span class="keyword">let</span> senderBalance = <span class="keyword">await</span> contract.balanceOf(accounts[<span class="number">0</span>]);</span><br><span class="line">    assert.equal(totalSupply.toNumber(), INITIAL_SUPPLY);</span><br><span class="line">    assert.equal(totalSupply.toNumber(), senderBalance.toNumbe());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>運行<code>truffle test</code>可看到測試通過的結果。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Contract: HelloToken</span><br><span class="line">    ✓ should met initial supply</span><br><span class="line"></span><br><span class="line">1 passing (11ms)</span><br></pre></td></tr></table></figure><h3 id="講解-v2">講解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should met initial supply'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要在程式碼中使用async/await，需要在函式前加入<code>async</code>宣告，這樣解譯器才會解析函式中的<code>await</code>語法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> contract = <span class="keyword">await</span> HelloToken.deployed();</span><br><span class="line"><span class="keyword">let</span> totalSupply = <span class="keyword">await</span> contract.totalSupply.call();</span><br><span class="line"><span class="keyword">let</span> senderBalance = <span class="keyword">await</span> contract.balanceOf(accounts[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>透過在非同步的操作前加上<code>await</code>宣告，這三行程式會依照順序，等待第一行await語句執行完，取得<code>contract</code>變數後，再依序執行第二行語句。第二行語句執行完，取得<code>totalSupply</code>變數後，再繼續執行第三行語句以取得<code>senderBalance</code>變數。</p><p>後面兩個assert語句則與promise撰寫時完全一樣。這樣改寫後，程式碼的可讀性大大地提昇了！</p><h2 id="加入轉帳測試">加入轉帳測試</h2><p>再透過<code>async/await</code>語句試著加入轉帳測試：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'should have right balance after transfer'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> AMOUNT = <span class="number">123</span>;</span><br><span class="line">  <span class="keyword">let</span> contract = <span class="keyword">await</span> HelloToken.deployed();</span><br><span class="line">  <span class="comment">// check init balance</span></span><br><span class="line">  <span class="keyword">let</span> account0Balance = <span class="keyword">await</span> contract.balanceOf(accounts[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">let</span> account1Balance = <span class="keyword">await</span> contract.balanceOf(accounts[<span class="number">1</span>]);</span><br><span class="line">  assert.equal(account0Balance.toNumber(), INITIAL_SUPPLY);</span><br><span class="line">  assert.equal(account1Balance.toNumber(), <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// check balance after transferred</span></span><br><span class="line">  <span class="keyword">await</span> contract.transfer(accounts[<span class="number">1</span>], AMOUNT);</span><br><span class="line">  account0Balance = <span class="keyword">await</span> contract.balanceOf(accounts[<span class="number">0</span>]);</span><br><span class="line">  account1Balance = <span class="keyword">await</span> contract.balanceOf(accounts[<span class="number">1</span>]);</span><br><span class="line">  assert.equal(account0Balance.toNumber(), INITIAL_SUPPLY - AMOUNT);</span><br><span class="line">  assert.equal(account1Balance.toNumber(), AMOUNT);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>運行<code>truffle test</code>可看到測試通過的結果。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Contract: HelloToken</span><br><span class="line">    ✓ should met initial supply</span><br><span class="line">    ✓ should have right balance after transfer (92ms)</span><br><span class="line"></span><br><span class="line">2 passing (151ms)</span><br></pre></td></tr></table></figure><h3 id="講解-v3">講解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> account0Balance = <span class="keyword">await</span> contract.balanceOf(accounts[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">let</span> account1Balance = <span class="keyword">await</span> contract.balanceOf(accounts[<span class="number">1</span>]);</span><br><span class="line">assert.equal(account0Balance.toNumber(), INITIAL_SUPPLY);</span><br><span class="line">assert.equal(account1Balance.toNumber(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>範例的前半部測試<code>帳號0</code>與<code>帳號1</code>中的代幣餘額。<code>帳號0</code>即部署代幣的帳號，因此擁有所有的<code>HelloToken</code>代幣，而<code>帳號1</code>中則沒有<code>HelloToken</code>代幣。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.transfer(accounts[<span class="number">1</span>], AMOUNT);</span><br></pre></td></tr></table></figure><p>接著呼叫合約的<code>transfer</code>方法將一些代幣轉入<code>帳號1</code>。注意這些都是非同步的操作（送出傳輸命令後，要先等待區塊鍊確認），因此需要使用<code>await</code>語句。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">account0Balance = <span class="keyword">await</span> contract.balanceOf(accounts[<span class="number">0</span>]);</span><br><span class="line">account1Balance = <span class="keyword">await</span> contract.balanceOf(accounts[<span class="number">1</span>]);</span><br><span class="line">assert.equal(account0Balance.toNumber(), INITIAL_SUPPLY - AMOUNT);</span><br><span class="line">assert.equal(account1Balance.toNumber(), AMOUNT);</span><br></pre></td></tr></table></figure><p>範例的後半部再次測試<code>帳號0</code>與<code>帳號1</code>中的代幣餘額。結果符合轉帳後兩個帳戶的預期代幣數額。</p><h2 id="結語">結語</h2><p><code>async/await</code>語句相當適合拿來寫非同步的程式，這特性太適合用來寫智能合約的測試了。因為<code>async/await</code>這語法太新，所以大部分的參考資料都還在用<code>Promise</code>來撰寫。我建議當你看到相關的智能合約測試時，可以用async/await改寫看看，會有很不一樣的感受。</p><h1>參考資料</h1><p>[1] Writing Tests in Javascript <a href="http://truffleframework.com/docs/getting_started/javascript-tests" target="_blank" rel="noopener">http://truffleframework.com/docs/getting_started/javascript-tests</a>[2] 6 Reasons Why JavaScript’s Async/Await Blows Promises Away (Tutorial)<a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" target="_blank" rel="noopener">https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因為智能合約一旦部署就難以修改，因此合約的安全性極其重要，要避免合約中出現一些基礎錯誤，除了透過第三方驗證外，完整地單元測試(unit test)也是必需的。&lt;/p&gt;
&lt;p&gt;目前最成熟的智能合約單元測試方式，還是透過&lt;code&gt;Truffle&lt;/code&gt;開發框架來達成。有
      
    
    </summary>
    
    
      <category term="ethereum" scheme="https://blog.gasolin.idv.tw/tags/ethereum/"/>
    
      <category term="javascript" scheme="https://blog.gasolin.idv.tw/tags/javascript/"/>
    
      <category term="solidity" scheme="https://blog.gasolin.idv.tw/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>在 Linux 上設定 Ledger Nano S 硬體錢包</title>
    <link href="https://blog.gasolin.idv.tw/2017/12/26/setup_ledger_nano_on_linux/"/>
    <id>https://blog.gasolin.idv.tw/2017/12/26/setup_ledger_nano_on_linux/</id>
    <published>2017-12-26T15:10:30.000Z</published>
    <updated>2018-03-31T08:09:13.246Z</updated>
    
    <content type="html"><![CDATA[<p>今天已把前陣子買到的 Ledget Nano S 硬體錢包在Windows 10/Elementary OS(/Ubuntu 16.04)上設定好，正式開始使用。和預期一樣，雖然在Linux上剛開始設定時需要多做一些步驟，但是一旦設定好後，使用過程和在其他平台上並沒有區別。</p><h1>硬體錢包</h1><p>過去透過NAS，外接硬碟等方式來保護自己的相片，作品等「數位資產」，以防哪天檔案遺失或外流。現在要守護的範圍更要擴及「加密代幣」，即保護自己的「數位財產」。</p><div class="mermaid">  graph LR作品 --> NAS相片 --> NAS相片 --> 線上備份NAS --> 數位資產線上備份 --> 數位資產加密代幣 --> 硬體錢包硬體錢包 --> 數位資產</div><p>MyEtherWallet網站<a href="https://myetherwallet.github.io/knowledge-base/hardware-wallets/hardware-wallet-recommendations.html" target="_blank" rel="noopener">推薦</a>任何擁有超過「2周的薪資」數位財產的人，使用「硬體錢包」來保管自己的「加密代幣」，以避免可能的財產損失。</p><p>目前Ledget Nano S和TREZOR是兩款較多人使用的硬體錢包。硬體錢包的安全性從產生錢包帳號開始。硬體錢包帳號的私鑰一直保存在硬體設備中，只要保存好「recovery phase」(Mnemonic Seed)，不會發生使用線上交易所時帳號或帳戶中的代幣可能被盜的風險。只有在發送代幣時需要解鎖錢包帳號。解鎖錢包帳號時，輸入PIN碼解鎖的過程，也是透過硬體錢包上的按鍵完成，從而避免了所使用的電腦可能已被入侵者安裝鍵盤側錄軟體而造成的財產上的風險。</p><h1>設定流程</h1><h2 id="1-設定-ledget-nano-s-硬體">1. 設定 Ledget Nano S 硬體</h2><p>在 Ledget Nano S 上透過按壓左右兩顆硬體按鈕，設定4~8字的PIN Code與24個單字的「recovery phase」，並用紙筆等實體方式記錄下來（千萬別用拍照的…）。完成後機器會隨機挑幾個次序測試，而你需要選擇對應的單字來確認安全性。如果以後機器壞了或遺失了，仍然可以透過這24個單字的「recovery phase」來取回帳號。</p><h2 id="2-在電腦上安裝-chrome-或-chromium">2. 在電腦上安裝 Chrome 或 Chromium</h2><p>因為目前 Ledger Nano S 使用Chrome App技術來提供桌面應用程式，Chrome也是唯一支援<a href="https://wicg.github.io/webusb/" target="_blank" rel="noopener">WebUSB API</a>的瀏覽器…Google近期公告Chrome App即將被Progressive Web App取代，我們拭目以待Ledger公司將拿出什麼方案來應對。</p><h2 id="3-安裝-ledger-manager">3. 安裝 Ledger Manager</h2><p>前往<a href="https://www.ledgerwallet.com/apps/manager" target="_blank" rel="noopener">https://www.ledgerwallet.com/apps/manager</a>安裝Ledger Manager。</p><h2 id="4-設定-usb-連線">4. 設定 USB 連線</h2><p>這時開啟Ledger Manager，將Ledget Nano S連線到電腦並解鎖，Ledger Manager無法找到對應的設備。</p><p>這時可以參考<a href="https://ledger.zendesk.com/hc/en-us/articles/115005165269-What-if-Ledger-Wallet-is-not-recognized-on-Linux-" target="_blank" rel="noopener">What if Ledger Wallet is not recognized on Linux?</a>在命令行環境下輸入以下命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget -q -O - https://www.ledgerwallet.com/support/add_udev_rules.sh | sudo bash</span><br></pre></td></tr></table></figure><p>執行後重新將Ledget Nano S連線到電腦並解鎖，可以看到Ledger Manager開始更新資料。</p><h2 id="4-安裝-ethereum-app">4. 安裝 Ethereum App</h2><p>Ledger Manager與Ledget Nano S連線後，除了可以更新韌體之外，也能安裝不同的「加密代幣」App進 Ledget Nano S。</p><p>這邊選擇安裝Ethereum App。</p><p>安裝完成後，在Ledget Nano S上可以看到多出一個<code>Ethereum</code>的圖示。</p><p>點選進入<code>Ethereum</code>，確認<code>Browser Support</code>選項為<code>No</code> (Ethereum &gt; Settings &gt; Browser Support &gt; No)，這樣稍後安裝的Ledger Wallet Ethereum才能辨識到 Ledget Nano S。</p><h2 id="5-安裝-ledger-wallet-ethereum">5. 安裝 Ledger Wallet Ethereum</h2><p>參考<a href="https://ledger.zendesk.com/hc/en-us/articles/115005199649-How-to-install-and-use-Ethereum-and-Ethereum-Classic-" target="_blank" rel="noopener">How to install and use Ethereum and Ethereum Classic?</a> 前往<a href="https://www.ledgerwallet.com/apps/ethereum" target="_blank" rel="noopener">https://www.ledgerwallet.com/apps/ethereum</a>下載Ledger Wallet Ethereum App。</p><p>安裝好後重新將Ledget Nano S連線到電腦並解鎖，可以看到相關操作界面。</p><h1>使用 MyEtherWallet 取代 Ledger Wallet Ethereum</h1><p>若不喜歡使用App，還可透過 MyEtherWallet 來存取。</p><p>參考<a href="https://myetherwallet.github.io/knowledge-base/migration/moving-from-private-key-to-ledger-hardware-wallet.html" target="_blank" rel="noopener">Moving from MyEtherWallet to Ledger</a> 和<a href="https://ledger.zendesk.com/hc/en-us/articles/115005200009-How-to-use-MyEtherWallet-with-Ledger" target="_blank" rel="noopener">How to use MyEtherWallet with Ledger</a> 這兩篇設定，將<code>Setting</code>中的<code>Contract Data</code>與<code>Browser support</code>選項都設成<code>Yes</code>，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ethereum &gt; Settings &gt; Contract Data &gt; Yes</span><br><span class="line">Ethereum &gt; Settings &gt; Browser Support &gt; Yes</span><br></pre></td></tr></table></figure><p>透過Chrome瀏覽器，在MyEtherWallet中看到<code>How would you like to access your wallet</code>選項時，選擇<code>Ledger Wallet</code>並在硬體上解鎖即可。</p><h1>參考資料</h1><ul><li>BIP39 Mnemonic Code Converter <a href="https://iancoleman.io/bip39/" target="_blank" rel="noopener">https://iancoleman.io/bip39/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天已把前陣子買到的 Ledget Nano S 硬體錢包在Windows 10/Elementary OS(/Ubuntu 16.04)上設定好，正式開始使用。和預期一樣，雖然在Linux上剛開始設定時需要多做一些步驟，但是一旦設定好後，使用過程和在其他平台上並沒有區別。
      
    
    </summary>
    
    
      <category term="ethereum" scheme="https://blog.gasolin.idv.tw/tags/ethereum/"/>
    
      <category term="linux" scheme="https://blog.gasolin.idv.tw/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Firefox 使用者導覽 (Onboarding)</title>
    <link href="https://blog.gasolin.idv.tw/2017/11/27/firefox-onboarding/"/>
    <id>https://blog.gasolin.idv.tw/2017/11/27/firefox-onboarding/</id>
    <published>2017-11-27T08:30:18.000Z</published>
    <updated>2018-03-31T08:09:13.242Z</updated>
    
    <content type="html"><![CDATA[<p>隨著Firefox 56，57版的推出，我參與製作的Firefox Onboarding功能也正式和大眾見面了。</p><h2 id="firefox-56">Firefox 56</h2><p>在Firefox 56版中當新使用者開啟瀏覽器時，會看到一個可愛的狐狸頭。<img src="https://i.imgur.com/5f4I31q.png" alt="Imgur"></p><p>點進去可以看到一些功能導覽頁面。<img src="https://i.imgur.com/WaOb0Fo.png" alt="Imgur"></p><p>點擊導覽頁面右下方的按鈕的話，會聚焦到瀏覽器對應的功能區塊上，使用者可以快速嘗試這些功能。<img src="https://i.imgur.com/JhNp2K4h.png" alt="Imgur"></p><p>我們也加入了Web assessibility，使用者可以只用鍵盤來瀏覽整個使用者導覽頁面。</p><h2 id="firefox-quantum-57">Firefox Quantum (57)</h2><p>經過使用者研究(User research)，在Firefox Quantum(57)版上我們針對Onboarding的體驗又做了不小的修改。</p><p><img src="https://i.imgur.com/EMDXiIX.png" alt="Imgur"></p><p>這次的更新除了主視覺與一些互動元素都變得不一樣之外，也加了個小彩蛋：新使用者(全新的profile)和從過去版本升級的使用者，所看到的功能導覽項目是不盡相同的喔。</p><p><img src="https://i.imgur.com/pGmPnM8.png" alt="Imgur"></p><p>有興趣進一步了解我們怎麼製作Onboarding Tour，可參考<a href="https://github.com/mozilla/gecko-dev/tree/master/browser/extensions/onboarding" target="_blank" rel="noopener">Onboarding文件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;隨著Firefox 56，57版的推出，我參與製作的Firefox Onboarding功能也正式和大眾見面了。&lt;/p&gt;
&lt;h2 id=&quot;firefox-56&quot;&gt;Firefox 56&lt;/h2&gt;
&lt;p&gt;在Firefox 56版中當新使用者開啟瀏覽器時，會看到一個可愛的狐狸頭。
      
    
    </summary>
    
    
      <category term="web" scheme="https://blog.gasolin.idv.tw/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>為 Elementary OS 設定中文環境</title>
    <link href="https://blog.gasolin.idv.tw/2017/11/04/chinese-in-elementary-os/"/>
    <id>https://blog.gasolin.idv.tw/2017/11/04/chinese-in-elementary-os/</id>
    <published>2017-11-04T11:19:48.000Z</published>
    <updated>2018-03-31T08:09:13.242Z</updated>
    
    <content type="html"><![CDATA[<p>在前一篇文章中我已經設定好了雙系統（Elementary OS/Windows 10）開機。在這篇中將繼續把系統的基礎中文環境（中文界面 + 輸入法）設定起來。感謝前路上的貢獻者讓整個過程變得相當容易。</p><p>設定好的中文環境如下<img src="https://i.imgur.com/WjBUcl6m.png" alt="Imgur"></p><h2 id="為什麼要用elementary-os">為什麼要用Elementary OS?</h2><p>其實Ubuntu等發行版的中文環境已經做得很好，如果使用Ubuntu等更成熟的發行版，基礎的中文環境都是預設好開箱即用的。</p><p>但我就是任性想用基於Ubuntu，但是界面看起來更養眼的<a href="https://elementary.io/zh_TW/" target="_blank" rel="noopener">Elementary OS</a>。</p><h2 id="調整語系">調整語系</h2><p><img src="https://i.imgur.com/TZRXNzGm.png" alt="Imgur"></p><p>首先，打開<code>Settings</code>中的<code>Language &amp; Region</code>，在左側<code>Installed Languages</code>選單中將界面切換到中文。並選擇完全安裝（Complete Installation）。</p><p>等待安裝好後重新登入，就可以看到全中文界面了。</p><p><img src="https://i.imgur.com/jVv0rNEm.png" alt="Imgur"></p><h2 id="安裝新酷音輸入法">安裝新酷音輸入法</h2><p>在安裝好 Elementary OS 0.4.1 後，預設並沒有輸入法選項，但其實內部已安裝了ibus輸入法框架。</p><p>因為沒有內建輸入法，所以若要使用輸入法，需要自行安裝。</p><p>在命令列中輸入以下命令以安裝新酷音輸入法</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install ibus-chewing</span><br></pre></td></tr></table></figure><p>安裝好後再輸入<code>ibus-setup</code>，可開啟輸入法設定畫面</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ibus-setup</span><br></pre></td></tr></table></figure><p>在 「輸入法」 分頁底下的 「漢語」 子選單當中可以加入剛安裝的新酷音輸入法。</p><p><img src="https://i.imgur.com/5EBSmC6.png" alt="Imgur"></p><p>按「確定」，在設定畫面中可以看到的新酷音輸入法。</p><p><img src="https://i.imgur.com/vhkdfvKm.png" alt="Imgur"></p><p>最後重要的步驟，就是將切換方式改成個人較習慣的<code>Ctrl+Space</code>。</p><p><img src="https://i.imgur.com/S4TZ1iRm.png" alt="Imgur"></p><p>如此一來，就可以在Elementary OS上輸入中文啦！這篇文章就是從截圖到文章編輯/上傳，全程在已照上述方式安裝好Elmentary OS基礎中文環境的筆電上完成的。</p><h3 id="fcitx-版">fcitx 版</h3><p>我也試了安裝fcitx版本的新酷音</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo apt install fcitx fcitx-chewing</span><br></pre></td></tr></table></figure><p>安裝好後使用<code>im-config</code>命令將預設輸入法框架切換成<code>fcitx</code>，重新開機後就可以看到輸入法圖示了。</p><h2 id="參考資料">參考資料</h2><ul><li>Ubuntu fcitx + chewing 新酷音輸入法 <a href="https://gist.github.com/tanyuan/c0d4ee15cf0c9c93da28cc1cf0ff87b3" target="_blank" rel="noopener">https://gist.github.com/tanyuan/c0d4ee15cf0c9c93da28cc1cf0ff87b3</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前一篇文章中我已經設定好了雙系統（Elementary OS/Windows 10）開機。在這篇中將繼續把系統的基礎中文環境（中文界面 + 輸入法）設定起來。感謝前路上的貢獻者讓整個過程變得相當容易。&lt;/p&gt;
&lt;p&gt;設定好的中文環境如下
&lt;img src=&quot;https:/
      
    
    </summary>
    
    
      <category term="linux" scheme="https://blog.gasolin.idv.tw/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Dual boot Elementary OS &amp; Windows 10 on XPS 13 (9360)</title>
    <link href="https://blog.gasolin.idv.tw/2017/10/25/xps13-elementary-os/"/>
    <id>https://blog.gasolin.idv.tw/2017/10/25/xps13-elementary-os/</id>
    <published>2017-10-25T06:40:48.000Z</published>
    <updated>2018-03-31T08:09:13.250Z</updated>
    
    <content type="html"><![CDATA[<p>I just successfully installed Elementary OS Luna (0.4.1) along side with Windows 10 on my new Dell XPS 9360 machine.</p><p>Comparing this XPS 13 <code>9360 (8th Gen i7)</code> with my previous model <code>9343 (5th Gen i7)</code>, the CPU is way faster(feels like 3 times faster), the wireless works well and the signal is stronger (which I was encountered some issues in XPS 13 9343), the keyboard feedback is pleasent, and the battery life did last longer in 9360.</p><p>Several settings are trickier than early days when I try to install *nux on Notebook. Here’s the self reference guide and hope it could help others.</p><h2 id="settings-on-windows">Settings on Windows</h2><h3 id="login-to-microsoft-account">Login to Microsoft account</h3><p>It’s necessary to bind your account with the device, so you can get recovery key later.</p><h3 id="flash-elementary-os-to-the-usb-disk">Flash Elementary OS to the USB disk</h3><p>I download the OS image from <a href="http://elementary.io/" target="_blank" rel="noopener">Elementary OS web site</a> and use <a href="https://unetbootin.github.io/" target="_blank" rel="noopener">Unetbootin</a> to flash the image into the disk.</p><h3 id="shrink-the-disk-space">Shrink the disk space</h3><p>I have the 256GB SSD, I use <a href="https://www.partitionwizard.com/" target="_blank" rel="noopener">Partition Wizard</a> to slice ~100GB for Elementary OS.</p><p>I have 8GB RAM so I <a href="https://askubuntu.com/questions/49109/i-have-16gb-ram-do-i-need-32gb-swap" target="_blank" rel="noopener">reference</a> the recommend swap size and left ~8GB for swap.</p><h3 id="disable-fast-startup">Disable fast startup</h3><p>I also need to follow the instructions to <a href="https://www.tenforums.com/tutorials/4189-turn-off-fast-startup-windows-10-a.html" target="_blank" rel="noopener">disable the fast startup</a> on Windows.</p><h3 id="switch-sata-operation-mode-from-raid-to-ahci">Switch SATA operation mode from RAID to AHCI</h3><p>Here’s the most tricky part. It takes me a while to figure out how to switch the SATA storage from RAID to AHCI. The trick is doing this procedure with <a href="http://triplescomputers.com/blog/uncategorized/solution-switch-windows-10-from-raidide-to-ahci-operation/" target="_blank" rel="noopener">Windows safe mode</a>.</p><h2 id="settings-on-bios">Settings on BIOS</h2><p>Press <code>F12</code> during booting.</p><ul><li>Don’t need to turn off the security boot.</li><li>Follow above link’s instructions to config SATA storage.</li><li>Save the configureation before exit.</li></ul><p>Reboot to windows and make sure windows runs nicely in safemode. Then follow above link’s instructions to jump out of safemode.</p><p>Now I’m prepared and able to install Elementary OS.</p><h2 id="install-elementary-os-through-usb-disk">Install Elementary OS through USB disk</h2><p>Install Elementary OS as usual Ubuntu distribution.</p><p>First connect to wifi and allow install 3rd party softwares.</p><p>Add the left space as <code>/</code>(root) with <code>Ext4</code> format. And set the left ~8GB as <code>SWAP</code> format.</p><p>Then continue the auto install process.</p><p>Now I have a clean Elementary OS.</p><h2 id="recover-windows-with-bitlocker-recovery-keys">Recover Windows with BitLocker recovery keys</h2><p>After restart I can see an option menu with Elementary OS and Windows Boot Manager.</p><p>I can boot to Elementary OS without major issue.</p><p>Well, I met the problem that AppCenter can’t start correctly, so I do <code>sudo apt update &amp;&amp; sudo apt upgrade</code> then <code>sudo apt purge appcenter &amp;&amp; sudo apt purge packagekit</code> then restart and run <code>sudo apt install appcenter &amp;&amp; sudo apt install packagekit</code> to make it work normally.</p><p>The input method and bluetooth pairing seems not work out of box, but I can live with that.</p><p>Then when I boot to Windows, I need to enter the BitLocker recovery keys. That could be solved by <a href="https://support.microsoft.com/en-us/help/17133/windows-8-bitlocker-recovery-keys-frequently-asked-questions" target="_blank" rel="noopener">following the FAQ from microsoft</a>. I need to login to Microsoft Account and find the recovery key.</p><p>Enter the recovery key then everything works.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I just successfully installed Elementary OS Luna (0.4.1) along side with Windows 10 on my new Dell XPS 9360 machine.&lt;/p&gt;
&lt;p&gt;Comparing thi
      
    
    </summary>
    
    
      <category term="linux" scheme="https://blog.gasolin.idv.tw/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>如何撰寫智能合約(Smart Contract)?(III)建立標準代幣</title>
    <link href="https://blog.gasolin.idv.tw/2017/09/16/howto-write-an-erc20-compatible-token/"/>
    <id>https://blog.gasolin.idv.tw/2017/09/16/howto-write-an-erc20-compatible-token/</id>
    <published>2017-09-16T09:35:31.000Z</published>
    <updated>2018-03-31T08:09:13.246Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.gasolin.idv.tw/2017/09/11/howto-write-a-simple-token/">上一篇</a>中我們已寫好並部署完成了簡單的加密代幣🔒💵合約。在閱讀完本文後，你將學會建立一個可以放到乙太幣錢包👛的加密代幣🔒💵。</p><h2 id="開發前的準備">開發前的準備</h2><p>延續上一篇的內容，在開發的過程中，我們將繼續使用<code>testrpc</code><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>工具在電腦上模擬智能合約所需的乙太坊區塊鏈測試環境。</p><p>首先確保已啟動testrpc。若尚未啟動，可以使用以下命令啟動：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ testrpc</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這邊有個值得一學的小技巧：在啟動testrpc時加上<code>--seed</code>參數，例如</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">testrpc --seed apple banana cherry</span><br></pre></td></tr></table></figure><p>這樣之後重新啟動testrpc時可以產生一樣的帳號(accounts)和私鑰(private key)。</p><h2 id="erc20標準">ERC20標準</h2><p>建立的代幣若要能透過乙太幣錢包👛來收送，必須相容於以太坊的ERC20標準<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。ERC20標準定義了支援錢包所必須的合約介面。</p><p>本篇將使用<code>OpenZeppelin</code><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>函式庫來簡化建立加密代幣🔒💵的過程。<code>OpenZeppelin</code>是一套協助撰寫安全的加密合約的函式庫，裡面也提供了相容ERC20標準的智能合約。可以透過npm工具安裝到專案目錄<code>node_modules/zeppelin-solodity/</code>中：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install zeppelin-solidity</span><br></pre></td></tr></table></figure><p>準備完成，我們可以開始建立新的加密代幣智能合約了。</p><h2 id="建立一個標準代幣合約">建立一個標準代幣合約</h2><p>在<code>contracts/</code>目錄下建立一個<code>HelloToken.sol</code>檔案。也可以使用以下命令來產生檔案：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ truffle create contract HelloToken</span><br></pre></td></tr></table></figure><p><code>HelloToken.sol</code>檔案內容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line">import &quot;zeppelin-solidity/contracts/token/StandardToken.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract HelloToken is StandardToken &#123;</span><br><span class="line">  string public name = &quot;HelloCoin&quot;;</span><br><span class="line">  string public symbol = &quot;H@&quot;;</span><br><span class="line">  uint8 public decimals = 2;</span><br><span class="line">  uint256 public INITIAL_SUPPLY = 88888;</span><br><span class="line"></span><br><span class="line">  function HelloToken() public &#123;</span><br><span class="line">    totalSupply = INITIAL_SUPPLY;</span><br><span class="line">    balances[msg.sender] = INITIAL_SUPPLY;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="講解">講解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br></pre></td></tr></table></figure><p>第一行指名目前使用的solidity版本，不同版本的solidity可能會編譯出不同的bytecode。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;zeppelin-solidity/contracts/token/StandardToken.sol&quot;;</span><br></pre></td></tr></table></figure><p>接著我們使用<code>import</code>語句，來讀入<code>zeppelin-solidity</code>提供的<code>StandardToken</code>合約。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract HelloToken is StandardToken &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立<code>HelloToken</code>合約時，使用<code>is</code>語句繼承了<a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/StandardToken.sol" target="_blank" rel="noopener">StandardToken</a>合約。因此<code>HelloToken</code>合約繼承了<code>StandardToken</code>合約所包含的資料與呼叫方法。</p><p>當我們繼承了<code>StandardToken</code>合約，也就支援了以下 ERC-20 標準中<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>規定的函式</p><table><thead><tr><th>函式</th><th>描述</th></tr></thead><tbody><tr><td>totalSupply()</td><td>代幣發行的總量</td></tr><tr><td>balanceOf(A)</td><td>查詢A帳戶下的代幣數目</td></tr><tr><td>transfer(A,x)</td><td>傳送x個代幣到A帳戶</td></tr><tr><td>transferFrom(A,x)</td><td>從A帳戶提取x個代幣</td></tr><tr><td>approve(A,x)</td><td>同意A帳戶從我的帳戶中提取代幣</td></tr><tr><td>allowance(A,B)</td><td>查詢B帳戶可以從A帳戶提取多少代幣</td></tr></tbody></table><p>和前一篇一樣，後面驗證時會用到<code>balanceOf</code>和<code>transfer</code>兩個函式。因為<code>StandardToken</code>合約中已經幫我們實做了這些函式，因此我們不需要自己從頭再寫一次。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string public name = &quot;HelloCoin&quot;;</span><br><span class="line">string public symbol = &quot;H@&quot;;</span><br><span class="line">uint8 public decimals = 2;</span><br><span class="line">uint256 public INITIAL_SUPPLY = 100000;</span><br></pre></td></tr></table></figure><p>這邊設定參數的目的是指定這個代幣的一些特性。以美元為例，美元的名稱(<code>name</code>)是<code>dollar</code>，美元的代號為<code>$</code>，拿一美元去找零最小可以拿到零錢是一美分(cent)，也就是0.01元。因為一美元最小可分割到小數點後2位(0.01)，因此最小交易單位(decimals)為2。</p><p>這邊將這個加密代幣取名(name)為<code>HelloCoin</code>(哈囉幣)，代幣的代號(symbol)為<code>H@</code>，最小分割單位是2(最小可以找0.01個哈囉幣)。</p><p>以下為美金，比特幣，以太幣，哈囉幣的對照表供參考：</p><table><thead><tr><th>Name</th><th>Symbol</th><th>decimals</th></tr></thead><tbody><tr><td>Dollar</td><td>$</td><td>2</td></tr><tr><td>Bitcoin</td><td>BTC</td><td>8</td></tr><tr><td>Ethereum</td><td>ETH</td><td>18</td></tr><tr><td>HelloCoin</td><td>H@</td><td>2</td></tr></tbody></table><p>最後也定義了初始代幣數目<code>INITIAL_SUPPLY</code>為<code>100000</code>。當我們把全域變數設為<code>public</code>(公開)，編譯時就會自動新增一個讀取公開變數的ABI接口，我們在<code>truffle console</code>中也可以讀取這些變數。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function HelloToken() public &#123;</span><br><span class="line">  totalSupply = INITIAL_SUPPLY;</span><br><span class="line">  balances[msg.sender] = INITIAL_SUPPLY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和合約同名的<code>HelloToken</code>方法，就是<code>HelloToken</code>合約的建構函式(constructor)。在建構式裡指定了<code>totalSupply</code>數目，並將所有的初始代幣<code>INITIAL_SUPPLY</code>都指定給<code>msg.sender</code>帳號，也就是用來部署這個合約的帳號。‵<code>totalSupply</code>定義於<a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20Basic.sol#L10" target="_blank" rel="noopener">ERC20Basic.sol</a>中，<code>balances</code>定義於<a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/BasicToken.sol#L15" target="_blank" rel="noopener">BasicToken.sol</a>中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;../math/SafeMath.sol&apos;;</span><br><span class="line">...</span><br><span class="line">using SafeMath for uint256;</span><br><span class="line">...</span><br><span class="line">balances[msg.sender] = balances[msg.sender].sub(_value);</span><br></pre></td></tr></table></figure><p>進一步追去看<a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/BasicToken.sol" target="_blank" rel="noopener">BasicToken.sol</a>合約的內容，可以發現<code>BasicToken.sol</code>合約中匯入了<code>SafeMath.sol</code>合約<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>。<code>SafeMath</code>對各種數值運算加入了必要的驗證，讓合約中的數字計算更安全。</p><p>如此一來，我們已寫好一個可透過以太幣錢包交易的新加密代幣🔒💵合約。如果將這個合約部署到乙太坊公開區塊鍊上，這個代幣合約就會一直存在，世界上從此也就多了一種新的加密代幣。只要你能找到人想擁有這種代幣，這種代幣就有交易的價值。</p><h3 id="編譯與部署">編譯與部署</h3><p>在<code>migrations/</code>目錄下建立一個<code>4_deploy_hellotoken.js</code>檔案，內容如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloToken = artifacts.require(<span class="string">"HelloToken"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">  deployer.deploy(HelloToken);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>現在執行compile與migrate命令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ truffle compile</span><br><span class="line">...</span><br><span class="line">$ truffle migrate --reset</span><br><span class="line">Using network <span class="string">'development'</span>.</span><br><span class="line"></span><br><span class="line">Running migration: 4_deploy_hellotoken.js</span><br><span class="line">  Deploying HelloToken...</span><br><span class="line">  ... 0x2c4659528c68b4e43d1edff6c989fba05e8e7e56cc4085d408426d339b4e9ba4</span><br><span class="line">  HelloToken: 0x352fa9aa18106f269d944935503afe57a00a9a0d</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0x1434c1b61e9719f410fc6090ce37c0ec141a1738aba278dd320738e4a5d229fa</span><br><span class="line">Saving artifacts...</span><br></pre></td></tr></table></figure><p>如此一來我們已將HelloCoin代幣合約部署到testrpc上。</p><h2 id="驗證">驗證</h2><p>我們一樣可以透過<code>truffle console</code>來驗證<code>HelloToken</code>是否部署成功。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ truffle console</span><br><span class="line">&gt; <span class="built_in">let</span> contract</span><br><span class="line">&gt; HelloToken.deployed().<span class="keyword">then</span>(instance =&gt; contract = instance)</span><br><span class="line">&gt; contract.address</span><br><span class="line"><span class="string">'0x352fa9aa18106f269d944935503afe57a00a9a0d'</span></span><br><span class="line">&gt; contract.balanceOf(web3.eth.coinbase)</span><br><span class="line">BigNumber &#123; s: 1, e: 5, c: [ 100000 ] &#125;</span><br><span class="line">&gt; contract.balanceOf(web3.eth.accounts[1])</span><br><span class="line">BigNumber &#123; s: 1, e: 0, c: [ 0 ] &#125;</span><br><span class="line">&gt; contract.transfer(web3.eth.accounts[1], 123)</span><br><span class="line">...</span><br><span class="line">&gt; contract.balanceOf(web3.eth.accounts[0])</span><br><span class="line">BigNumber &#123; s: 1, e: 4, c: [ 99877 ] &#125;</span><br><span class="line">&gt; contract.balanceOf(web3.eth.accounts[1])</span><br><span class="line">BigNumber &#123; s: 1, e: 2, c: [ 123 ] &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h3 id="講解-v2">講解</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">let</span> contract</span><br><span class="line">&gt; SimpleToken.deployed().<span class="keyword">then</span>(instance =&gt; contract = instance)</span><br></pre></td></tr></table></figure><p>這邊使用<code>HelloToken.deployed().then</code>語句來取得HelloToken合約的Instance(實例)，並存到<code>contract</code>變數中，以方便後續的呼叫。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; contract.balanceOf(web3.eth.coinbase)</span><br><span class="line">BigNumber &#123; s: 1, e: 5, c: [ 100000 ] &#125;</span><br><span class="line">&gt; contract.balanceOf(web3.eth.accounts[1])</span><br><span class="line">BigNumber &#123; s: 1, e: 0, c: [ 0 ] &#125;</span><br></pre></td></tr></table></figure><p><code>web3.eth.coinbase</code> 代表操作者預設的帳號，即testrpc所提供的10個帳號中的第一個帳號，也可以透過<code>web3.eth.accounts[0]</code>取得。這兩句的目的是在進行轉帳操作前，先查詢前兩個帳號所擁有的代幣餘額。透過呼叫<code>balanceOf</code>函式，可以看到第一個帳號(部署合約的帳號)裡存著所有的代幣。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; contract.transfer(web3.eth.accounts[1], 123)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接著使用<code>transfer</code>函式來傳送<code>123</code>個代幣到第二個帳號<code>web3.eth.accounts[1]</code>。如果轉帳成功，傳送者預設帳號中會減少<code>123</code>個代幣，接收者帳號中會增加<code>123</code>個代幣。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; contract.balanceOf(web3.eth.accounts[0])</span><br><span class="line">BigNumber &#123; s: 1, e: 4, c: [ 99877 ] &#125;</span><br><span class="line">&gt; contract.balanceOf(web3.eth.accounts[1])</span><br><span class="line">BigNumber &#123; s: 1, e: 2, c: [ 123 ] &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>我們再次透過呼叫<code>balanceOf</code>函式，查詢傳送者帳號和接收者帳號各自剩下的HelloToken數目。發現轉帳真的成功了。</p><h2 id="結語">結語</h2><p>我們用到 <code>OpenZeppelin</code>提供的函式庫來簡化撰寫加密代幣合約的工作。要實際投入使用前，還是建議將呼叫到的程式碼都再審查幾遍。可以從 OpenZeppelin 自己提供的Audit開始看<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>，可以學到一些觀念。</p><h2 id="參考資料">參考資料</h2><ul><li>[1] <a href="https://github.com/ethereumjs/testrpc" target="_blank" rel="noopener">https://github.com/ethereumjs/testrpc</a></li><li>[2] ERC20 <a href="https://theethereum.wiki/w/index.php/ERC20_Token_Standard" target="_blank" rel="noopener">https://theethereum.wiki/w/index.php/ERC20_Token_Standard</a> 或 <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md" target="_blank" rel="noopener">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md</a></li><li>[3] OpenZeppelin <a href="https://github.com/OpenZeppelin/zeppelin-solidity" target="_blank" rel="noopener">https://github.com/OpenZeppelin/zeppelin-solidity</a></li><li>[4] OpenZeppelin Audit <a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/audit/ZeppelinAudit.md" target="_blank" rel="noopener">https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/audit/ZeppelinAudit.md</a></li><li>[5] An Ethereum Hello World Smart Contract for Beginners part 1 <a href="http://www.talkcrypto.org/blog/2017/04/17/an-ethereum-hello-world-smart-contract-for-beginners-part-1/" target="_blank" rel="noopener">http://www.talkcrypto.org/blog/2017/04/17/an-ethereum-hello-world-smart-contract-for-beginners-part-1/</a></li><li>[6] <a href="http://www.talkcrypto.org/blog/2017/04/22/an-ethereum-hello-world-smart-contract-for-beginners-part-2/" target="_blank" rel="noopener">http://www.talkcrypto.org/blog/2017/04/22/an-ethereum-hello-world-smart-contract-for-beginners-part-2/</a></li><li>[7] OpenZeppelin <a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol" target="_blank" rel="noopener">SafeMath 合約</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.gasolin.idv.tw/2017/09/11/howto-write-a-simple-token/&quot;&gt;上一篇&lt;/a&gt;中我們已寫好並部署完成了簡單的加密代幣🔒💵合約。在閱讀完本文後，你將學會建立一個可以放到乙太幣錢包👛
      
    
    </summary>
    
    
      <category term="ethereum" scheme="https://blog.gasolin.idv.tw/tags/ethereum/"/>
    
      <category term="javascript" scheme="https://blog.gasolin.idv.tw/tags/javascript/"/>
    
      <category term="solidity" scheme="https://blog.gasolin.idv.tw/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>如何撰寫智能合約(Smart Contract)?(II)建立加密代幣</title>
    <link href="https://blog.gasolin.idv.tw/2017/09/11/howto-write-a-simple-token/"/>
    <id>https://blog.gasolin.idv.tw/2017/09/11/howto-write-a-simple-token/</id>
    <published>2017-09-11T16:47:31.000Z</published>
    <updated>2018-03-31T08:09:13.246Z</updated>
    
    <content type="html"><![CDATA[<p>Update: 12/28/2017 更新教程，使用require取代throw。</p><p><a href="https://blog.gasolin.idv.tw/2017/09/06/howto-write-a-smart-contract/">上一篇</a>中我們已寫好並部署完成了第一個智能合約，也驗證了合約確實可以運作。在閱讀完本篇後，你將學會建立一個簡易的加密代幣🔒💵。本篇目的並非為了寫出一個安全可用的加密代幣，而是以介紹代幣合約的相關概念為主， 是以對合約做了適當地簡化，好更易於理解。</p><h2 id="開發前的準備">開發前的準備</h2><p>延續上一篇的內容，在開發的過程中，我們將繼續使用<code>testrpc</code><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>工具在電腦上模擬智能合約所需的乙太坊區塊鏈測試環境。</p><p>首先確保已啟動testrpc，若尚未啟動，可以使用以下命令啟動</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ testrpc</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這樣我們就可以開始建立加密代幣智能合約專案了。</p><h2 id="代幣合約的基礎概念">代幣合約的基礎概念</h2><p>代幣合約扮演像是銀行🏦的角色。使用者在代幣合約中，用自己的乙太幣帳戶地址當作銀行帳戶，可以透過代幣合約執行轉帳(transfer，將代幣由一個帳戶傳送到另一個帳戶)，查詢餘額(balanceOf，查詢指定帳戶中擁有的代幣)等原本由銀行負責的工作。因為合約部署在公開區塊鏈上，所有的交易都是公開透明，可供檢驗的。</p><h2 id="建立一個代幣合約">建立一個代幣合約</h2><p>在<code>contracts/</code>目錄下建立一個<code>SimpleToken.sol</code>檔案。也可以使用以下命令來產生檔案：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ truffle create contract SimpleToken</span><br></pre></td></tr></table></figure><p><code>SimpleToken.sol</code>檔案內容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line">  uint256 INITIAL_SUPPLY = 10000;</span><br><span class="line">  mapping(address =&gt; uint256) balances;</span><br><span class="line"></span><br><span class="line">  function SimpleToken() public &#123;</span><br><span class="line">    balances[msg.sender] = INITIAL_SUPPLY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // transfer token for a specified address</span><br><span class="line">  function transfer(address _to, uint256 _amount) public &#123;</span><br><span class="line">    require(balances[msg.sender] &gt; _amount);</span><br><span class="line">    balances[msg.sender] -= _amount;</span><br><span class="line">    balances[_to] += _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Gets the balance of the specified address</span><br><span class="line">  function balanceOf(address _owner) public constant returns (uint256) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="講解">講解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br></pre></td></tr></table></figure><p>第一行指名目前使用的solidity版本，不同版本的solidity可能會編譯出不同的bytecode。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uint256 INITIAL_SUPPLY = 10000;</span><br><span class="line">mapping(address =&gt; unit256) balances;</span><br></pre></td></tr></table></figure><p>我們定義了初始代幣數目<code>INITIAL_SUPPLY</code>。這邊隨意選擇了一個數字<code>10000</code>。</p><p>我們用<code>mapping</code>來定義一個可以儲存鍵值對(key-value pair)的資料結構(類似Javascript中的<code>{&quot;0xaabbccddeeff&quot;: 888}</code>)，同時也需要分別指定<code>address</code>作為鍵的型別，指定<code>uint256</code>作為值的型別。和Javascript不同，型別定義好後不能隨時更改要儲存的型別。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract SimpleToken &#123;</span><br><span class="line">  function SimpleToken() public &#123;</span><br><span class="line">    balances[msg.sender] = INITIAL_SUPPLY;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和合約同名的<code>SimpleToken</code>函式，就是<code>SimpleToken</code>這個合約的建構函式(constructor)。函式中我們拿<code>msg.sender</code>當作key，<code>INITIAL_SUPPLY</code>當作值，將所有的初始代幣<code>INITIAL_SUPPLY</code>都指定給<code>msg.sender</code>帳號。<code>msg</code>是一個全域(Global)物件<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，<code>msg.sender</code>表示用作呼叫當前函式的帳號。由於建構函式只有在合約部署時會被執行，因此這邊用到的<code>msg.sender</code>，也就代表著用來部署這個合約的帳號。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function transfer(address _to, uint256 _amount) public &#123;</span><br><span class="line">  require(balances[msg.sender] &gt; _amount);</span><br><span class="line">  balances[msg.sender] -= _amount;</span><br><span class="line">  balances[_to] += _amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>transfer</code>函式定義了如何<code>轉帳</code>，只要指定要傳送的帳號與數目，就會從呼叫者手上把對應數目的代幣移轉到指定的帳號上。</p><div class="mermaid">  graph LR傳送者 -- 轉帳 --> 代幣合約代幣合約 -.-> 修改傳送者和接收者餘額</div><p><code>require(balances[msg.sender] &gt; _amount);</code>語句判斷帳戶中是否還有足夠轉出的餘額，若存款小於想轉出的數目，就丟出錯誤。</p><p>這個函式這麼寫當然還是過度簡化了，若要能實際使用，需要檢查更多可能的狀況。但就先這樣吧。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function balanceOf(address _owner) public constant returns (uint256) &#123;</span><br><span class="line">  return balances[_owner];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>balanceOf</code>函式的作用，是讓使用者可以查詢任一帳號的餘額。透過傳入<code>_owner</code>帳號，可以查詢<code>_owner</code>帳號儲存在<code>balances</code>對照表中的值。</p><div class="mermaid">  graph LR傳送者 --> 代幣合約代幣合約 -. 查詢結果 .-> 傳送者</div><p>如此一來，我們就寫好一個新加密代幣🔒💵合約囉！接下來將要編譯合約並部署到區塊鏈上。</p><h3 id="編譯與部署">編譯與部署</h3><p>在<code>migrations/</code>目錄下建立一個<code>3_deploy_token.js</code>檔案，內容如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SimpleToken = artifacts.require(<span class="string">"SimpleToken"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">  deployer.deploy(SimpleToken);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>現在可執行compile與migrate命令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ truffle compile</span><br><span class="line">...</span><br><span class="line">$ truffle migrate</span><br><span class="line">Using network <span class="string">'development'</span>.</span><br><span class="line"></span><br><span class="line">Running migration: 3_deploy_token.js</span><br><span class="line">  Deploying HelloToken...</span><br><span class="line">  ... 0x2c4659528c68b4e43d1edff6c989fba05e8e7e56cc4085d408426d339b4e9ba4</span><br><span class="line">  SimpleToken: 0x352fa9aa18106f269d944935503afe57a00a9a0d</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0x1434c1b61e9719f410fc6090ce37c0ec141a1738aba278dd320738e4a5d229fa</span><br><span class="line">Saving artifacts...</span><br></pre></td></tr></table></figure><p>如此一來我們已將<code>SimpleToken</code>代幣合約部署到testrpc上。</p><h2 id="驗證">驗證</h2><p>合約部署完成後，我們可以使用<code>truffle console</code>命令開啟console，輸入以下命令來驗證合約是否能照我們設計的方式運作。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ truffle console</span><br><span class="line">&gt; <span class="built_in">let</span> contract</span><br><span class="line">&gt; SimpleToken.deployed().<span class="keyword">then</span>(instance =&gt; contract = instance)</span><br><span class="line">&gt; contract.balanceOf(web3.eth.coinbase)</span><br><span class="line">BigNumber &#123; s: 1, e: 4, c: [ 10000 ] &#125;</span><br><span class="line">&gt; contract.balanceOf(web3.eth.accounts[1])</span><br><span class="line">BigNumber &#123; s: 1, e: 0, c: [ 0 ] &#125;</span><br><span class="line">&gt; contract.transfer(web3.eth.accounts[1], 123)</span><br><span class="line">...</span><br><span class="line">&gt; contract.balanceOf(web3.eth.coinbase)</span><br><span class="line">BigNumber &#123; s: 1, e: 3, c: [ 9877 ] &#125;</span><br><span class="line">&gt; contract.balanceOf.call(web3.eth.accounts[1])</span><br><span class="line">BigNumber &#123; s: 1, e: 2, c: [ 123 ] &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h3 id="講解-v2">講解</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">let</span> contract</span><br><span class="line">&gt; SimpleToken.deployed().<span class="keyword">then</span>(instance =&gt; contract = instance)</span><br></pre></td></tr></table></figure><p>這邊使用<code>SimpleToken.deployed().then</code>語句來取得SimpleToken合約的Instance(實例)，並存到<code>contract</code>變數中，以方便後續的呼叫。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; contract.balanceOf(web3.eth.coinbase)</span><br><span class="line">BigNumber &#123; s: 1, e: 4, c: [ 10000 ] &#125;</span><br><span class="line">&gt; contract.balanceOf(web3.eth.accounts[1])</span><br><span class="line">BigNumber &#123; s: 1, e: 0, c: [ 0 ] &#125;</span><br></pre></td></tr></table></figure><p>還記得啟動testrpc後預設會產生10個帳號(Accounts)嗎?。<code>web3.eth.coinbase</code> 代表操作者預設的帳號，即10個帳號中的第一個帳號<code>web3.eth.accounts[0]</code>，所以這邊呼叫<code>web3.eth.coinbase</code>或<code>web3.eth.accounts[0]</code>結果是一樣的。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; contract.balanceOf(web3.eth.accounts[0])</span><br><span class="line">BigNumber &#123; s: 1, e: 4, c: [ 10000 ] &#125;</span><br></pre></td></tr></table></figure><p>這兩句的目的是在進行轉帳操作前，先查詢前兩個帳號所擁有的代幣餘額。透過呼叫<code>balanceOf</code>函式，可以看到第一個帳號(部署合約的帳號)裡存著所有的代幣。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; contract.transfer(web3.eth.accounts[1], 123)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接著使用<code>transfer</code>函式來傳送<code>123</code>個代幣到第二個帳號<code>web3.eth.accounts[1]</code>。如果轉帳成功，傳送者預設帳號中會減少123個代幣，接收者帳號中會增加123個代幣。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; contract.balanceOf(web3.eth.coinbase)</span><br><span class="line">BigNumber &#123; s: 1, e: 3, c: [ 9877 ] &#125;</span><br><span class="line">&gt; contract.balanceOf.call(web3.eth.accounts[1])</span><br><span class="line">BigNumber &#123; s: 1, e: 2, c: [ 123 ] &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>我們再次透過呼叫<code>balanceOf</code>函式，查詢傳送者帳號和接收者帳號各自剩下的SimpleToken數目。發現轉帳真的成功了。</p><h2 id="你知道剛剛的程式碼裡有一堆安全漏洞💣嗎">你知道剛剛的程式碼裡有一堆安全漏洞💣嗎?</h2><p>寫智能合約看起來並不困難吧？但因為智能合約的運作是透明公開的，而且其中牽涉了代幣或金錢的流動，這提供了駭客很強的挑戰動機。</p><p>因此如果要妥善處理智能合約，會遇到的諸多安全問題。即使單純如本篇中的<code>SimpleToken</code>，也至少會遇到幾個問題：例如<code>transfer</code>函式中沒有禁止傳入負數金額，因此傳送者反過來可以從接收者那邊取得代幣。同時也沒有檢查接收者帳號是否合法，因此傳送者可能會傳送失敗或因為送到黑洞中，白白損失了代幣。</p><p>有著一堆安全漏洞的合約，輕則執行失敗白花交易費用，嚴重則影響到合約中的代幣或以太幣。已有多起因為合約的漏洞，造成儲存在合約中的代幣或以太幣被駭客轉走，使得ICO失敗的案例。</p><p>有興趣的人可以進一步查看參考資料<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>和<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>了解智能合約當前的一些最佳實現。</p><h2 id="結語">結語</h2><p>看完這篇除了學到本篇講解的<code>SimpleToken</code>外，應該也可以大致看得懂truffle預設的<code>MetaCoin.sol</code>合約了。不同的細節可以查看solidity相關語法<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。下一篇會接著介紹如何使用經過驗證的函式庫，來建立一份可以放到乙太幣錢包👛的加密代幣🔒💵合約。</p><h2 id="參考資料">參考資料</h2><ul><li>[1] <a href="https://github.com/ethereumjs/testrpc" target="_blank" rel="noopener">https://github.com/ethereumjs/testrpc</a></li><li>[2] Units and Globally Available Variables <a href="http://solidity.readthedocs.io/en/develop/units-and-global-variables.html" target="_blank" rel="noopener">http://solidity.readthedocs.io/en/develop/units-and-global-variables.html</a></li><li>[3] An Ethereum Hello World Smart Contract for Beginners <a href="http://www.talkcrypto.org/blog/2017/04/17/an-ethereum-hello-world-smart-contract-for-beginners-part-1/" target="_blank" rel="noopener">part 1</a>, <a href="http://www.talkcrypto.org/blog/2017/04/22/an-ethereum-hello-world-smart-contract-for-beginners-part-2/" target="_blank" rel="noopener">part 2</a></li><li>[4] Onward with Ethereum Smart Contract Security <a href="https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702" target="_blank" rel="noopener">https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702</a></li><li>[5] Ethereum Contract Security Techniques and Tips <a href="https://github.com/ConsenSys/smart-contract-best-practices" target="_blank" rel="noopener">https://github.com/ConsenSys/smart-contract-best-practices</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Update: 12/28/2017 更新教程，使用require取代throw。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.gasolin.idv.tw/2017/09/06/howto-write-a-smart-contract/&quot;&gt;上一篇&lt;/a&gt;中我
      
    
    </summary>
    
    
      <category term="ethereum" scheme="https://blog.gasolin.idv.tw/tags/ethereum/"/>
    
      <category term="javascript" scheme="https://blog.gasolin.idv.tw/tags/javascript/"/>
    
      <category term="solidity" scheme="https://blog.gasolin.idv.tw/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>如何撰寫智能合約(Smart Contract)?(I)</title>
    <link href="https://blog.gasolin.idv.tw/2017/09/06/howto-write-a-smart-contract/"/>
    <id>https://blog.gasolin.idv.tw/2017/09/06/howto-write-a-smart-contract/</id>
    <published>2017-09-06T10:30:31.000Z</published>
    <updated>2018-03-31T08:09:13.246Z</updated>
    
    <content type="html"><![CDATA[<p>Update: 11/30/2017 更新教程，使用<a href="https://github.com/trufflesuite/truffle/releases/tag/v4.0.0" target="_blank" rel="noopener">Truffle 4.0.1</a>。</p><p><a href="https://blog.gasolin.idv.tw/2017/09/02/what-is-smart-contract/">上一篇</a>中介紹了智能合約📒是什麼，也概略描述了從編譯到部署智能合約的流程，接下來將介紹如何使用solidity語言來寫智能合約。</p><h2 id="使用solidity語言撰寫智能合約">使用solidity語言撰寫智能合約</h2><p>Ethereum上的智能合約需要使用<code>solidity</code><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>語言來撰寫。雖然還有其他能用來撰寫智能合約的語言如<code>Serpent</code>(類Python)、<code>lll</code>(類Fortran)，但目前看到所有公開的智能合約都是使用solidity撰寫。</p><p>宣傳上說，solidity是一種類似Javascript的語言，而且圍繞著solidity的各種開發工具鏈，都是使用屬於Javascript生態系的npm來提供的。但我覺得solidity還是比較像Java或C#。因為和Javascript不同，solidity與Java或C#同屬於強型別(Strong Type，在定義變數時需要指定型別)語言、在定義函式(function)時同樣需指定回傳的型別(type)、同樣也需要先編譯才能執行。這些特性都是Javascript所不具備的。</p><h2 id="開發前的準備">開發前的準備</h2><p>本文將使用當前最活躍的智能合約開發框架<code>truffle</code><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>為基礎來開發。之前提到過的ENS(Ethereum Name Service)<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>也是採用truffle框架。其他選擇還有<code>embark</code><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>等。</p><p>就像一般網站或App開發一樣，在提供公開服務之前，開發者會在自己用於寫程式的電腦(又稱作本機)💻或透過測試網路🕸來測試程式執行的效果，測試完成後，才會部署到公開的網路上提供服務。開發區塊鏈智能合約(程式)的過程也是如此。特別是公開鏈上所有寫入或讀取計算結果的操作都需要真金白銀(虛擬代幣)💸，而且根據網路狀況，每個公開鏈上的操作都需要要一小段反應時間(15秒 ~ 數分鐘)，這些等待頗浪費寶貴的開發時間⏳。因此在開發的過程中，我們將使用<code>testrpc</code><sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>工具在電腦上模擬智能合約所需的乙太坊區塊鏈測試環境。</p><p>testrpc中也包含了Javascript版本的Ethereum虛擬機(Ethereum Virtual Machine)<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>，因此可以完整地執行智能合約😇。</p><p>此外，開發前還需準備一個合手的編輯器。我目前是使用<a href="https://code.visualstudio.com" target="_blank" rel="noopener">Visual Studio Code</a>搭配<a href="https://marketplace.visualstudio.com/items?itemName=JuanBlanco.solidity" target="_blank" rel="noopener">solidity</a>插件來開發。solidity插件除了支援語法高亮之外，也會透過Solium<sup id="fnref:11"><a href="#fn:11" rel="footnote">11</a></sup>檢查並提示基本的語法錯誤，相當方便。其他編輯器應該也有類似的插件可選擇。</p><h3 id="安裝所需工具">安裝所需工具</h3><p>首先開發機上必須裝好Node.js，再使用以下命令安裝所需的工具：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install -g ethereumjs-testrpc truffle</span><br></pre></td></tr></table></figure><h3 id="啟動-testrpc">啟動 Testrpc</h3><p>安裝好後隨時可以使用<code>testrpc</code>命令來啟動乙太坊測試環境。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ testrpc</span><br><span class="line">Available Accounts</span><br><span class="line">==================</span><br><span class="line">(0) 0xa4d7ce9137e6f8de4fb1311595b33230be15be50</span><br><span class="line">(1) 0x26c231bdd7c8a7304983b04694c3437b30331019</span><br><span class="line">(2) 0xe238ccca936dcdbd48f0cf3a1e6f147d04b55527</span><br><span class="line">(3) 0x769ed341bf83cc86e5037cb78388012d6e2d9cc9</span><br><span class="line">(4) 0x72a084c80195de79e5cd8dca59488e67982f65d7</span><br><span class="line">(5) 0xcfda0765b0a82721d2f59581f53846a12e392999</span><br><span class="line">(6) 0x4b0349aea768b4e1ed4cec683f8f7dd112729fea</span><br><span class="line">(7) 0x643c305f0b3844984d7f1f7b9f3ab93a73dfdfcf</span><br><span class="line">(8) 0x2ee0a7974326604442dca127d02fac4957ab3e8a</span><br><span class="line">(9) 0xe00e57db1772f6e81bcccc982e565a10ae26ab92</span><br><span class="line"></span><br><span class="line">Private Keys</span><br><span class="line">==================</span><br><span class="line">(0) 7de56fb677edc8d0c7a1f3a6d5bcb8f73ce257d44996e9b5fc8ad414af38a22a</span><br><span class="line">(1) 4401de20cf287d15d1c062005d866a35cd82e2a73f8cb43ec0cb90b117d1ec38</span><br><span class="line">(2) 8f51f9100a81218343d44a047ae3b0be5d80d262a13fbef24dc569b3e335e820</span><br><span class="line">(3) 241a0ff98dfb6f290dbee909c9a7a4eea2de3a2174e7cddf834868ea03f80fa9</span><br><span class="line">(4) ce1108cc6763bc74658068a55b080c6ccbfb1bd26e609588b81c07d13affc70d</span><br><span class="line">(5) f9614c1fd34224787e6c95bbe881fb28fd0fdc00808ef85d0430505f4a348690</span><br><span class="line">(6) 4c1baad08f720f5c5754bb185e66490b45e3480aa3ec419e4b76f7a81118b296</span><br><span class="line">(7) af9af2c6b519d49605cc58b719240299e5e8b9a89a7e94a85625734fc30c46bd</span><br><span class="line">(8) 55ab79ae6de4fad5b98bc1dfd795b945ba8e7d92dcc88073f9e3fdfef471f69f</span><br><span class="line">(9) e9299fb391c8830370991659780933e6b62269e32a8cbc55a29aa5f73df995a2</span><br><span class="line"></span><br><span class="line">HD Wallet</span><br><span class="line">==================</span><br><span class="line">Mnemonic:      addict cherry medal cupboard bless reduce oven beauty egg gift pledge exact</span><br><span class="line">Base HD Path:  m/44<span class="string">'/60'</span>/0<span class="string">'/0/&#123;account_index&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到testrpc啟動後自動建立了10個帳號(Accounts)，與每個帳號對應的私鑰(Private Key)🔑。每個帳號中都有100個測試用的以太幣(Ether)💵。要注意testrpc僅運行在記憶體中，因此每次重開時都會回到全新的狀態。</p><p>一切準備就緒，我們可以開始建立第一份智能合約專案了。</p><h2 id="建立專案">建立專案</h2><p>開啟另一個命令列視窗，輸入以下命令以建立專案：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ mkdir hello</span><br><span class="line">$ <span class="built_in">cd</span> hello</span><br><span class="line">$ truffle init</span><br></pre></td></tr></table></figure><p>如此一來，我們已建立好第一份智能合約專案了。</p><p>在<code>demo/</code>資料夾下，可以看到<code>contracts/</code>資料夾，裡面放的是這個專案所包含的所有solidity程式。我們在<code>contracts/</code>資料夾中額外建立一個<code>HelloWorld.sol</code>檔案。（或者也可以用<code>truffle create contract HelloWorld</code>命令來建立）</p><p><code>HelloWorld.sol</code>檔案內容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract HelloWorld &#123;</span><br><span class="line">    function sayHello() public returns (string) &#123;</span><br><span class="line">        return (&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="講解">講解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br></pre></td></tr></table></figure><p>第一行指名目前使用的solidity版本，不同版本的solidity可能會編譯出不同的bytecode。</p><p>想要知道當前的solidity版本，也可以用 <code>truffle version</code> 命令來查看當前使用的truffle與solidity版本：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ truffle version</span><br><span class="line">Truffle v4.0.1 (core: 4.0.1)</span><br><span class="line">Solidity v0.4.18 (solc-js)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract HelloWorld &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>contract</code>關鍵字類似於其他語言中較常見的<code>class</code>。因為solidity是專為智能合約(Contact)設計的語言，宣告<code>contract</code>後即內建了開發智能合約所需的功能。也可以把這句理解為<code>class HelloWorld extends Contract</code>。</p><p>雖然一個.sol檔案中可以定義多個Contract，但建議一個.sol檔案中只定義一個Contract以便於後續的維護。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sayHello() public returns (string) &#123;</span><br><span class="line">    return (&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函式的結構與其他程式類似，但如果有傳入的參數或回傳值，需要指定參數或回傳值的型別(type)。所有支援的型別可以查看參考資料<sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup>。</p><p>solidity官方推薦的縮排風格為4個空格<sup id="fnref:13"><a href="#fn:13" rel="footnote">13</a></sup>。</p><h2 id="編譯">編譯</h2><p>現在執行<code>truffle compile</code>命令，我們可以將<code>HelloWorld.sol</code>原始碼編譯成Ethereum bytecode。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ truffle compile</span><br></pre></td></tr></table></figure><p>編譯成功的話，在<code>build/contracts/</code>目錄下會多出<code>HelloWorld.json</code>這個檔案。（在Windows平台上執行truffle compile若遇到問題，可以查看參考資料<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>來解決。）</p><h2 id="部署">部署</h2><p>為了將寫好的solidity程式碼部署到區塊鍊上，我們需要做一些相應的設定。</p><h3 id="遷移">遷移</h3><p>truffle框架中提供了方便部署合約的腳本。我們可以在<code>migrations/</code>目錄下維護這些腳本。這些腳本除了能部署合約，也可以用來遷移合約中的資料。建立<code>migrations/2_deploy_contracts.js</code>檔案(這些腳本使用Javascript撰寫)，將內容修改如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloWorld = artifacts.require(<span class="string">"HelloWorld"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">  deployer.deploy(HelloWorld);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這些migration檔案會依照檔案的<code>編號</code>來執行。例如<code>2_</code>就會在<code>1_</code>之後執行。檔案後面的文字只為協助開發者理解之用。</p><p>在檔案中可使用<code>artifacts.require</code>語句來取得準備部署的合約。使用<code>deployer.deploy</code>語句將合約部署到區塊鏈上。這邊<code>HelloWorld</code>是<code>contract</code>的名稱而不是檔名。因此可以用此語法讀入任一<code>.sol</code>檔案中的任一合約。</p><h3 id="區塊網路設定">區塊網路設定</h3><p>為了與<code>testrpc</code>連線，需要打開<code>truffle.js</code>並加入以下設定：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// See &lt;http://truffleframework.com/docs/advanced/configuration&gt;</span></span><br><span class="line">  <span class="comment">// to customize your Truffle configuration!</span></span><br><span class="line">  networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">      host: <span class="string">"localhost"</span>,</span><br><span class="line">      port: <span class="number">8545</span>,</span><br><span class="line">      network_id: <span class="string">"*"</span> <span class="comment">// Match any network id</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>truffle 使用 Javascript 的 Object 格式來定義設定。這邊定義了<code>development</code>網路為<code>localhost:8545</code>，即testrpc所提供的網路位址。</p><h3 id="部署-v2">部署</h3><p>現在執行<code>truffle migrate</code>命令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ truffle migrate</span><br><span class="line">Using network <span class="string">'development'</span>.</span><br><span class="line"></span><br><span class="line">Running migration: 1_initial_migration.js</span><br><span class="line">...</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">Running migration: 2_deploy_contracts.js</span><br><span class="line">...</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">...</span><br><span class="line">Saving artifacts...</span><br></pre></td></tr></table></figure><p>如此一來合約已經部署到testrpc中。切換到testrpc視窗，可以看到testrpc有反應了。</p><h3 id="與合約互動">與合約互動</h3><p>truffle提供命令行工具，執行<code>truffle console</code>命令後，可用Javascript來和剛剛部署的合約互動。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ truffle console</span><br><span class="line">&gt; <span class="built_in">let</span> contract</span><br><span class="line">&gt; HelloWorld.deployed().<span class="keyword">then</span>(instance =&gt; contract = instance)</span><br><span class="line">&gt; contract.sayHello.call()</span><br><span class="line"><span class="string">'Hello World'</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="講解-v2">講解</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; HelloWorld.deployed().then(<span class="function"><span class="params">instance</span> =&gt;</span> contract = instance)</span><br></pre></td></tr></table></figure><p><code>truffle console</code>中預載了<code>truffle-contract</code><sup id="fnref:12"><a href="#fn:12" rel="footnote">12</a></sup>函式庫，以方便操作部署到區塊鏈上的合約。</p><p>這邊使用<code>HelloWorld.deployed().then</code>語句來取得HelloWorld合約的Instance(實例)，並存到<code>contract</code>變數中，以方便後續的呼叫。</p><p>上面用的是Javascript ES6+的語法，這句也可以寫成</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HelloWorld.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  hello = instance;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; contract.sayHello.call()</span><br><span class="line"><span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><p>這邊直接呼叫<code>contract.sayHello()</code>也會得到一樣的結果。<code>truffle-contract</code>提供使用<code>call()</code>來讀取唯讀(read only)的資料，這樣就不需提供gas。因此如果遇到的操作需要向區塊鏈寫入資料，我們就不能用<code>call</code>語句了。</p><p>如此一來，我們已寫好並部署完成了第一個智能合約，也驗證了合約確實可以運作。</p><h3 id="加入新方法">加入新方法</h3><p>我們在<code>HelloWorld.sol</code>中再加入一個<code>echo</code>方法，<code>echo</code>方法接受輸入一個參數，並回傳傳送的參數。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function echo(string name) constant returns (string) &#123;</span><br><span class="line">  return name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的<code>echo</code>方法中傳入了一個<code>name</code>參數。我們也為<code>echo</code>方法加入一個<code>constant</code>宣告，表示呼叫這個方法並不會改變區塊鏈的狀態。如此一來，透過<code>truffle-contract</code>來呼叫此方法時，會自動選用<code>call</code>來呼叫，也不需要額外提供gas。</p><p>由於更新了合約內容，我們需要先重新新編譯一次，將編譯結果部署到testrpc上，再透過<code>truffle console</code>執行看看結果。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ truffle compile</span><br><span class="line">...</span><br><span class="line">$ truffle migrate --reset</span><br><span class="line">...</span><br><span class="line">$ truffle console</span><br><span class="line">&gt; <span class="built_in">let</span> contract</span><br><span class="line">&gt; HelloWorld.deployed().<span class="keyword">then</span>(instance =&gt; contract = instance)</span><br><span class="line">&gt; contract.echo(<span class="string">"yo man"</span>)</span><br><span class="line"><span class="string">'yo man'</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><code>echo</code>方法確實將我們輸入的內容回傳了。同時因為宣告了<code>constant</code>，我們不需要直接呼叫<code>call()</code>方法，<code>truffle</code>會自動選用call來呼叫。</p><p>另一點需要注意的，是這次如果還是用<code>truffle migrate</code>命令，我們會得到如下訊息：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ truffle migrate</span><br><span class="line">Using network <span class="string">'development'</span>.</span><br><span class="line"></span><br><span class="line">Network up to date.</span><br></pre></td></tr></table></figure><p>Truffle會告訴你現在網路上的合約都已是最新的，但事實上剛剛程式中新增的方法並沒有更新到區塊鏈上。要更新區塊鏈上已部署的程式，需要改寫<code>migrations</code>中的腳本，但現在還不到介紹migration的時候。還好我們開發用的區塊鏈是怎麼修改都沒關係的testrpc，可以使用<code>truffle migrate --reset</code>命令直接重新在testrpc上部署一次🎉。</p><h2 id="使用truffle-develop命令">使用truffle develop命令</h2><p>truffle 4.0.0 版本之後加入了<code>truffle develop</code>命令。這個命令讓我們不需要另外安裝testrpc等環境，就能直接上手開發。</p><p>例如</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">truffle develop</span><br><span class="line">Truffle Develop started at http://localhost:9545/</span><br><span class="line"></span><br><span class="line">Accounts:</span><br><span class="line">(0) 0x627306090abab3a6e1400e9345bc60c78a8bef57</span><br><span class="line">(1) 0xf17f52151ebef6c7334fad080c5704d77216b732</span><br><span class="line">(2) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef</span><br><span class="line">(3) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544</span><br><span class="line">(4) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2</span><br><span class="line">(5) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e</span><br><span class="line">(6) 0x2191ef87e392377ec08e7c08eb105ef5448eced5</span><br><span class="line">(7) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5</span><br><span class="line">(8) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc</span><br><span class="line">(9) 0x5aeda56215b167893e80b4fe645ba6d5bab767de</span><br><span class="line"></span><br><span class="line">Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br><span class="line"></span><br><span class="line">truffle(develop)&gt; compile</span><br><span class="line">truffle(develop)&gt; migrate</span><br><span class="line">Using network <span class="string">'develop'</span>.</span><br><span class="line">Running migration: 1_initial_migration.js</span><br><span class="line">  Deploying Migrations...</span><br><span class="line">...</span><br><span class="line">Saving artifacts...</span><br><span class="line">Running migration: 2_deploy_contracts.js</span><br><span class="line">  Deploying HelloWorld...</span><br><span class="line">...</span><br><span class="line">Saving artifacts...</span><br><span class="line">truffle(develop)&gt; <span class="built_in">let</span> contract</span><br><span class="line">truffle(develop)&gt; HelloWorld.deployed().<span class="keyword">then</span>(instance =&gt;contract = instance)</span><br><span class="line">...</span><br><span class="line">truffle(develop)&gt; contract.sayHello.call()</span><br><span class="line"><span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><p>可以看到，在命令行中輸入<code>truffle develop</code>命令，可以直接在裡面執行<code>compile</code>，<code>migrate</code>指令，還可以直接使用<code>console</code>命令所提供的與區塊鍊互動等功能。</p><h2 id="結語">結語</h2><p>本篇設計的範例<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup>相當簡單，但已達到完整地帶大家快速⚡️走一遍智能合約開發流程的目的。要透過智能合約實現各種功能，可以參考<a href="http://solidity.readthedocs.io/en/latest/solidity-by-example.html" target="_blank" rel="noopener">Solidity by example</a> 和 <a href="http://truffleframework.com/docs/getting_started/" target="_blank" rel="noopener">Truffle getting started</a> 網站學習更多的內容。也歡迎讀者留言，分享學習資源或提供建議。</p><p>下一篇會接著介紹如何建立一份簡單的加密代幣🔒💵合約。</p><h2 id="參考資料">參考資料</h2><ul><li>[1] Solidity <a href="http://solidity.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">http://solidity.readthedocs.io/en/latest/index.html</a></li><li>[2] Solidity線上編輯器　<a href="https://ethereum.github.io/browser-solidity/" target="_blank" rel="noopener">https://ethereum.github.io/browser-solidity/</a></li><li>[3] Truffle Framework <a href="http://truffleframework.com/" target="_blank" rel="noopener">http://truffleframework.com/</a></li><li>[4] Embark Framework <a href="https://github.com/iurimatias/embark-framework" target="_blank" rel="noopener">https://github.com/iurimatias/embark-framework</a></li><li>[5] ENS也使用Truffle框架 <a href="https://github.com/ethereum/ens" target="_blank" rel="noopener">https://github.com/ethereum/ens</a></li><li>[6] <a href="https://github.com/ethereumjs/testrpc" target="_blank" rel="noopener">https://github.com/ethereumjs/testrpc</a></li><li>[7] <a href="https://github.com/ethereumjs/ethereumjs-vm" target="_blank" rel="noopener">https://github.com/ethereumjs/ethereumjs-vm</a></li><li>[8] HelloWorld範例修改自 <a href="https://app.pluralsight.com/library/courses/blockchain-fundamentals/" target="_blank" rel="noopener">https://app.pluralsight.com/library/courses/blockchain-fundamentals/</a></li><li>[9]  Truffle issue on windows <a href="http://truffleframework.com/docs/advanced/configuration#resolving-naming-conflicts-on-windows" target="_blank" rel="noopener">http://truffleframework.com/docs/advanced/configuration#resolving-naming-conflicts-on-windows</a></li><li>[10] Solidity支援的型別(Type) <a href="https://solidity.readthedocs.io/en/develop/types.html" target="_blank" rel="noopener">https://solidity.readthedocs.io/en/develop/types.html</a></li><li>[11] Solium syntax check <a href="https://github.com/duaraghav8/Solium" target="_blank" rel="noopener">https://github.com/duaraghav8/Solium</a></li><li>[12] <a href="http://truffleframework.com/docs/getting_started/contracts" target="_blank" rel="noopener">http://truffleframework.com/docs/getting_started/contracts</a></li><li>[13] Coding Style <a href="http://solidity.readthedocs.io/en/develop/style-guide.html" target="_blank" rel="noopener">http://solidity.readthedocs.io/en/develop/style-guide.html</a></li><li>[14] 本篇也已分享到medium上的Taipei Ethereum Meetup台灣以太坊社群專欄　<a href="https://medium.com/taipei-ethereum-meetup/%E5%A6%82%E4%BD%95%E6%92%B0%E5%AF%AB%E6%99%BA%E8%83%BD%E5%90%88%E7%B4%84-smart-contract-i-363d06b1965b" target="_blank" rel="noopener">https://medium.com/taipei-ethereum-meetup/如何撰寫智能合約-smart-contract-i-363d06b1965b</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Update: 11/30/2017 更新教程，使用&lt;a href=&quot;https://github.com/trufflesuite/truffle/releases/tag/v4.0.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Truffle 4.
      
    
    </summary>
    
    
      <category term="ethereum" scheme="https://blog.gasolin.idv.tw/tags/ethereum/"/>
    
      <category term="javascript" scheme="https://blog.gasolin.idv.tw/tags/javascript/"/>
    
      <category term="solidity" scheme="https://blog.gasolin.idv.tw/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>什麼是智能合約(Smart Contract)?</title>
    <link href="https://blog.gasolin.idv.tw/2017/09/02/what-is-smart-contract/"/>
    <id>https://blog.gasolin.idv.tw/2017/09/02/what-is-smart-contract/</id>
    <published>2017-09-02T14:14:48.000Z</published>
    <updated>2018-03-31T08:09:13.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="智能合約是什麼">智能合約是什麼?</h2><p>在區塊鏈上運行的程式，通常稱為智能合約(Smart Contract)📒。所以通常會把&quot;寫區塊鏈程式&quot;改稱作&quot;寫智能合約&quot;。雖然比特幣(Bitcoin)上也能寫智能合約，但是比特幣所支援的語法僅與交易有關，能做的事情比較有限。因此目前提到寫智能合約，通常指的是支援執行圖靈完備程式的以太坊(Ethereum)區塊鏈⛓。</p><h2 id="智能合約可以做什麼">智能合約可以做什麼</h2><p>目前最常見的智能合約是各種加密貨幣合約💷，開發者可以很容易地透過部署一個智能合約，來提供運行於以太坊上的新加密代幣。如果這份智能合約相容於ERC20標準<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，開發者不需要重新開發從挖礦到交易的整個代幣生態系，你的新加密代幣就可以直接使用支援以太坊的電子錢包💰來收送，大大降低了建立新加密代幣的門檻。</p><p>智能合約也讓募資💸變得更透明。參與者投資資金或提供服務，也可獲得相應的權益。這份權益可以用代幣的形式返還給參與者。同樣地如果這代幣相容於ERC20標準<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，投資者或贊助者還可以隨時交易這些代幣。讓資金的運用變得更加彈性，也降低了投資的門檻。</p><p>除此之外，智能合約也可以用來運作各式公開公正的自動服務機構(DAO，Decentralized Autonomous Organization)🏦。透過分散在全球各節點上運作的智能合約，所有運作與決策都是公開透明的，降低了交易的不確定性(Uncertainty)。</p><h2 id="智能合約和一般程式的差異">智能合約和一般程式的差異</h2><p>以太坊智能合約確實有些和一般程式不同的特性，以下整理了四個不同點。</p><h3 id="一-整合金流容易">一，整合金流容易</h3><p>一般的應用程式要整合金流是件非常不容易的事情。而智能合約極容易整合金流系統(使用以太幣或自行建立的新代幣合約)。</p><h3 id="二-部署時與後續寫入時需費用">二，部署時與後續寫入時需費用</h3><p>一般的應用程式需要提供網址讓使用者下載，一般的網頁應用程式也需要運行在伺服器上，開發者需要維持伺服器的運作以提供服務，這需要持續地花費（就算是免費的伺服器或網頁空間，也是廠商自行吸收了費用），程式開始運作後，除了維持費用外不需額外的花費。</p><p>智能合約在部署時需要一筆費用，這筆費用將分給參與交易驗證（挖礦）的人。而在合約部署成功後，合約會作為不可更改的區塊鏈的一部分，分散地儲存在全球各地以太坊的節點上。也因此，智能合約在部署後，並不需定期提供維持費用，同時查詢已寫入區塊鏈的靜態資料時也不需費用。只有在每次透過智能合約寫入或讀取計算結果時，需要提供一小筆交易費用。</p><h3 id="三-儲存資料的成本更高">三，儲存資料的成本更高</h3><p>一般的應用程式將資料儲存在本機或伺服器上，需要資料時再從本機或伺服器上讀取，而智能合約將資料儲存在區塊鏈上，儲存資料所需的時間與成本相對昂貴。</p><h3 id="四-部署後無法更改">四，部署後無法更改</h3><p>一般的應用程式改版時可透過安裝新版程式，網頁應用程式也可透過部署新版程式達成，而智能合約一旦部署到區塊鏈上後，就無法更改這個智能合約。當然聰明的開發者透過加入額外的智能合約，也已有辦法繞過智能合約部署後無法再更改的限制。</p><h2 id="如何撰寫智能合約？">如何撰寫智能合約？</h2><p>Ethereum上的智能合約需要使用solidity<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>語言來撰寫。之前還有其他能用來撰寫智能合約的語言如Serpent(類Python)、lll(類Fortran)，但目前看到所有公開的智能合約都是使用solidity撰寫。官方宣傳上說solidity是一種類似Javascript的語言，而且圍繞著solidity的各種開發工具鏈都是使用屬於Javascript生態系的npm來提供的。</p><h2 id="將智能合約部署到區塊鏈的流程">將智能合約部署到區塊鏈的流程</h2><p>寫好solidity程式碼(.sol)後，需要先將程式碼編譯(compile)成EVM(Ethereum Virtual Machine)能讀懂的二進位Contract ByteCode，才能部署到Ethereum的區塊鏈上執行。部署到區塊鏈上的合約會有一個和錢包地址（Address）一樣格式的合約地址（Contract Address）。</p><div class="mermaid">  graph LRsubgraph local.sol -- compile --> bytecode[Contract Bytecode]endsubgraph ethereumbytecode -- deploy --> Contractend</div><p>部署後智能合約可自動執行。後續呼叫智能合約的時候，使用者可以使用部署合約的錢包地址(Owner Account)，或依據撰寫的智能合約條件，讓其他錢包地址也能呼叫這個智能合約。所謂的&quot;呼叫智能合約&quot;，其實就是向這個合約地址發起交易，只是交易的不只是代幣，而可以是智能合約提供的呼叫方法。</p><div class="mermaid">  graph LRsubgraph localAccountendsubgraph ethereumAccount -- call --> ContractContract --> EVMend</div><h2 id="有點抽象-來個例子？-🌰">有點抽象，來個例子？ 🌰</h2><p>在<a href="https://blog.gasolin.idv.tw/2017/08/13/got-my-ens-domain/">收到我的ENS網域啦 gasolin.eth</a>這篇文章中，我介紹了申請Ethereum Name Service的心得。其實ENS本身就是一堆智能合約的集合，透過這些智能合約，一起提供了Ethereum Name Service從申請，競價，到設定地址對應的服務。</p><p>要和智能合約互動，除了需要有合約地址外，還需要知道合約所提供的操作介面(Application Binary Interface，ABI)，即知道如何呼叫程式提供的功能，和如何解釋程式回傳的資料。ABI（JSON格式）檔案在從原始碼編譯成ByteCode時會一併產生。</p><p>下圖即是ENS Public Resolver這個合約的地址和ABI。<img src="https://i.imgur.com/y6jvpAUl.png" alt=""></p><p>準備好合約地址和ABI後，我們才能呼叫對應功能來存取合約。<img src="https://i.imgur.com/5550HgNl.png" alt="Imgur"></p><p>在<a href="https://blog.gasolin.idv.tw/2017/09/06/howto-write-a-smart-contract/">下一篇</a>中，我將簡單介紹如何撰寫Solidity程式。</p><h2 id="參考資料">參考資料</h2><ul><li>[1] ERC20 <a href="https://theethereum.wiki/w/index.php/ERC20_Token_Standard" target="_blank" rel="noopener">https://theethereum.wiki/w/index.php/ERC20_Token_Standard</a></li><li>[2] Solidity <a href="http://solidity.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">http://solidity.readthedocs.io/en/latest/index.html</a></li><li>[3] migration contracts <a href="http://truffleframework.com/docs/getting_started/migrations" target="_blank" rel="noopener">http://truffleframework.com/docs/getting_started/migrations</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;智能合約是什麼&quot;&gt;智能合約是什麼?&lt;/h2&gt;
&lt;p&gt;在區塊鏈上運行的程式，通常稱為智能合約(Smart Contract)📒。所以通常會把&amp;quot;寫區塊鏈程式&amp;quot;改稱作&amp;quot;寫智能合約&amp;quot;。雖然比特幣(Bitcoin)上也能寫智能合約，
      
    
    </summary>
    
    
      <category term="ethereum" scheme="https://blog.gasolin.idv.tw/tags/ethereum/"/>
    
  </entry>
  
  <entry>
    <title>個人工具箱2017九月</title>
    <link href="https://blog.gasolin.idv.tw/2017/08/31/tooling-in-2017-sep/"/>
    <id>https://blog.gasolin.idv.tw/2017/08/31/tooling-in-2017-sep/</id>
    <published>2017-08-31T16:01:00.000Z</published>
    <updated>2018-03-31T08:09:13.246Z</updated>
    
    <content type="html"><![CDATA[<p><code>先記錄下來手邊使用的工具，才有機會從繁雜中歸納出簡單的使用規則。</code></p><p>2011<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>年時紀錄了一次當時的個人工具箱，去年開始再次紀錄<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。今年給自己定的一大目標是個人自動化。年初開始紀錄自己工具箱的改變<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>🤹，持續更新。</p><h2 id="主要裝備">主要裝備</h2><ul><li>💻Macbook Air 13&quot;, 2012年版</li><li>📱<a href="https://oneplus.net/global/3" target="_blank" rel="noopener">One Plus 3</a>, Android, 6GB RAM, 5.5&quot; AMOLED</li><li>💻Dell XPS 13 (4943), Windows 10, i7 2.4GHz x2, 8GB RAM, 13&quot; LCD</li><li>📙Kindle Voyage</li><li>🖥Desktop PC, <a href="https://elementary.io/" target="_blank" rel="noopener">Elementary OS</a>, Intel i7 3770 3.40GHz x8, 16GB RAM, GeForce GT 630, 23&quot; LCD x2</li><li>📦Synology NAS: 電影，影集，照片，資料備份</li></ul><p>和年初相比的改變：</p><p>主力用Macbook Air，用回Macbook Air的主因，是因為目前工作中一定得用到的mozreview預期年底會淘汰，懶得為每台機器重新做設定。而且在Windows上編譯工作用的東西還是不太順手。桌機多擺了一台螢幕，雙螢幕工作。</p><h3 id="🕸網站工具">🕸網站工具</h3><ul><li>🕸主要瀏覽器：<a href="https://www.mozilla.org/en-US/firefox/products/" target="_blank" rel="noopener">Firefox Nightly</a></li><li>👥主要社交網站：<a href="http://www.facebook.com/" target="_blank" rel="noopener">Facebook</a>、<a href="https://twitter.com/gasolin" target="_blank" rel="noopener">Twitter</a></li><li>✅<a href="https://todoist.com/" target="_blank" rel="noopener">Todoist</a> (付費)</li><li>✉️<a href="http://mail.google.com/" target="_blank" rel="noopener">GMail</a>, Inbox</li><li>📆<a href="http://www.google.com/calendar" target="_blank" rel="noopener">Google日曆</a></li><li>📝Google Doc, <a href="http://keep.google.com/" target="_blank" rel="noopener">Google keep</a> 記事</li><li>💾個人網路硬碟：<a href="http://www.dropbox.com/" target="_blank" rel="noopener">Dropbox</a>, 主要用作同步照片，</li><li>🔑密碼管理：<a href="https://www.lastpass.com/" target="_blank" rel="noopener">Lasspass</a></li><li>📒記帳: <a href="https://toshl.com" target="_blank" rel="noopener">Toshl</a> (付費)</li><li>📰新聞聚合：<a href="https://feedly.com/" target="_blank" rel="noopener">Feedly</a></li><li><a href="https://share.readmoo.com/" target="_blank" rel="noopener">Readmoo分享書</a></li><li><a href="http://www.douban.com/" target="_blank" rel="noopener">豆瓣</a> 看電影記錄</li><li>🗂個人網站：<a href="http://www.gasolin.idv.tw" target="_blank" rel="noopener">個人網站</a>, <a href="https://github.com/gasolin/blog/" target="_blank" rel="noopener">Github</a></li><li>🗂個人履歷：<a href="https://www.linkedin.com/in/fredglin/" target="_blank" rel="noopener">Linkedin</a></li><li>🔗IFTTT <a href="https://blog.gasolin.idv.tw/2017/02/02/personal-automation-in-2017/">自動化生活紀錄2017</a></li><li>📺<a href="https://www.youtube.com/" target="_blank" rel="noopener">Youtube</a></li><li>👛電子錢包<a href="https://www.myetherwallet.com/" target="_blank" rel="noopener">MyEtherWallet</a></li></ul><p>和年初相比的改變：</p><p>使用多年的Anobii已經漸漸缺乏維護，嘗試使用<a href="https://share.readmoo.com/" target="_blank" rel="noopener">Readmoo分享書</a>替代，但就我繁，簡，英文書交換著看的情況，Readmoo分享書能掃到的書實在有限，因此今年到目前已看的書漏記了不少😓。</p><p>此外也付費訂閱<a href="https://todoist.com/" target="_blank" rel="noopener">Todoist</a>和<a href="https://toshl.com" target="_blank" rel="noopener">Toshl</a>兩種工具服務。</p><h3 id="設計">設計</h3><ul><li>Mockup：<a href="http://www.balsamiq.com/products/mockups" target="_blank" rel="noopener">Balsmiq Mockups</a></li><li>錄螢幕動畫：<a href="http://www.recordit.co/" target="_blank" rel="noopener">Recordit</a></li></ul><h3 id="開發">開發</h3><ul><li>編輯器：Visual Studio Code</li><li>版本控制：git, git-cinnabar</li><li>套件管理：apt, <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>, yarn, Chocolatey(windows)</li><li>Shell: zsh</li></ul><p>Ubuntu bash on windows用起來還不夠穩定，目前在Windows上盡量能用Chocolatey處理的就用Chocolatey處理。</p><h3 id="常用插件">常用插件</h3><p>Browser</p><ul><li>Emoji cheatsheet</li><li>A Weel translation</li><li>Context Plus</li><li>Grammarly (付費)</li></ul><p>Grammarly 可以自動找出英文語法錯誤，相當方便。</p><p>VSCode</p><ul><li>Git Blame</li><li>Document This</li><li>EditorConfig for VS Code</li><li>WakaTime</li><li>solidity</li></ul><p>JS</p><ul><li>Babel</li><li>ESlint</li></ul><h3 id="娛樂">娛樂</h3><ul><li>🎮Nintendo Switch</li><li>🎮Steam / vlc</li></ul><p>因為攜帶便利，現在主要只玩NS上的遊戲。Steam上看到喜歡的遊戲，也盡量等NS上出了再買。</p><h2 id="📱android-手機">📱Android 手機</h2><ul><li>瀏覽器：Firefox for Android (Nightly)</li><li>網頁更新通知：Web Alert</li><li>閱讀：Palabre (feedly), Readmoo</li><li>稍候閱讀：Pocket</li><li>信箱：Gmail, Inbox</li><li>地圖：Google地圖</li><li>記事：Keep</li><li>內建相機, 內建時鐘</li><li>相簿：Dropbox, Google相簿</li><li>社交：Facebook, LINE, Twitter, WeChat</li><li>待辦事項：<a href="https://play.google.com/store/apps/details?id=com.todoist" target="_blank" rel="noopener">Todoist</a>* 密碼管理：<a href="https://play.google.com/store/apps/details?id=com.lastpass.lpandroid" target="_blank" rel="noopener">LastPass</a></li><li>記帳: <a href="https://play.google.com/store/apps/details?id=com.thirdframestudios.android.expensoor" target="_blank" rel="noopener">Toshl</a></li><li>線上影片：Youtube</li><li>有聲書：Audible</li><li>音樂：豆瓣FM</li><li>健康：小米運動, Pokemon Go</li></ul><p>工具</p><ul><li>公事：Expensify, Duo Mobile</li><li>旅遊：Google翻譯, TripAdvisor</li><li>影片播放：MX Player, DS video (少用)</li><li>記錄看書狀況：Readmoo分享書</li><li>線上學習：Udemy, Pluralsight</li><li>IFTTT</li><li>💳街口支付</li><li>拼字訂正：Grammarly</li></ul><h2 id="reference">Reference</h2><ul><li><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> <a href="https://blog.gasolin.idv.tw/2013/01/02/%E5%80%8B%E4%BA%BA%E5%B7%A5%E5%85%B7%E7%AE%B12011/">個人工具箱2011</a></li><li><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> <a href="https://blog.gasolin.idv.tw/2016/12/19/tooling-in-2016/">個人工具箱2016</a></li><li><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> <a href="https://blog.gasolin.idv.tw/2017/02/02/tooling-in-2017/">個人工具箱2017</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;先記錄下來手邊使用的工具，才有機會從繁雜中歸納出簡單的使用規則。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2011&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;年時紀錄了一次當時的個人工具箱，去年開始
      
    
    </summary>
    
    
      <category term="life" scheme="https://blog.gasolin.idv.tw/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>以太坊(Ethereum)是什麼？</title>
    <link href="https://blog.gasolin.idv.tw/2017/08/18/what-is-ethereum/"/>
    <id>https://blog.gasolin.idv.tw/2017/08/18/what-is-ethereum/</id>
    <published>2017-08-18T15:21:31.000Z</published>
    <updated>2018-03-31T08:09:13.250Z</updated>
    
    <content type="html"><![CDATA[<p>以太坊(Ethereum)是近幾年才發展起來的一種新的底層<a href="https://blog.gasolin.idv.tw/2017/08/10/what-is-blockchain/">區塊鏈</a>技術。以太幣(Ether)是以太坊公有鏈上產生的🔒💵加密貨幣(Crypto　Currency)，除了可以拿來像比特幣(Bitcoin)一樣做交易外，還具有實際的用途。</p><p>以太坊和比特幣一樣是基於P2P網路與密碼學建立起的區塊鏈機制，不同之處是，以太坊在每個運作的節點上都運行著一個以太坊虛擬機(Ethereum Virtual Machine, EVM)，可以用來執行完整的程式。這些程式在以太坊中被稱為⚖📒<strong>智能合約</strong>(Smart Contract)。智能合約除了可以處理資料，還內建轉帳功能，可以很容易地透過智能合約來交易加密貨幣。由於智能合約可在每個以太坊的節點上執行並進行驗證，所以計算結果被認為是可信任的。以太坊還開發出了<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API" target="_blank" rel="noopener">web3.js</a>讓開發者可以使用網頁技術撰寫智能合約的操作介面。這樣的網頁操作介面又稱為🕸🅰<strong>分散式應用程式</strong>(DAPP)。要使用DAPP，必須在支援DAPP的瀏覽器中才能使用(如<a href="https://github.com/ethereum/mist/releases" target="_blank" rel="noopener">Mist</a>或<a href="https://parity.io/" target="_blank" rel="noopener">Parity</a>)。</p><p>使用智能合約技術製作的服務，也構成了以太坊生態圈的一環。例如<a href="https://blog.gasolin.idv.tw/2017/08/13/got-my-ens-domain/">Ethereum Name Service(ENS)</a>就提供了讓使用者更容易尋找到轉帳對象、智能合約，和DAPP的方式。</p><p>以太坊提供了便於交易的加密貨幣以太幣(Ether)，可透過智能合約解決交易上的信任問題，同時也可撰寫DAPP來提供友善的資訊彙總與操作介面，讓以太坊成為一個目前最理想的區塊鏈底層技術。</p><div class="mermaid">  graph TDDAPP -.- DAPP瀏覽器DAPP瀏覽器 -.- 智能合約錢包 -.- 智能合約智能合約 --- 以太坊錢包 -.- 以太幣以太幣 --- 以太坊以太幣 --- 激勵機制以太坊 --- P2P以太坊 --- 共識機制共識機制 --- 密碼學P2P --- 網際網路分散式APP -.- ENS智能合約 -.- ENS以太幣 -.- ENS</div><h2 id="以太幣-ether-的實際用途">以太幣(Ether)的實際用途</h2><p>在電腦上執行的一般的程式碼，寫出來可能會有迴圈不斷執行(死迴圈)的情況，搬到區塊鏈上亦然。那麼以太坊怎麼解決這個問題呢？以太坊開發者想到的辦法是讓執行的程式碼變得有價。EVM裡支援的所有的指令(OPCODE)都有<a href="https://github.com/ethereum/pyethereum/blob/develop/ethereum/opcodes.py" target="_blank" rel="noopener">明碼標價</a>，執行智能合約需要消耗與執行的指令數量相當的以太幣。在智能合約的術語中，這些拿來消耗的以太幣被稱為&quot;gas&quot;(燃料)。部署合約到區塊鏈上時，需要附加一定數量的燃料。當燃料消耗完而程式還沒執行完，就會出現&quot;Out of Gas&quot;(燃料耗盡)錯誤。智能合約透過這樣的方式來避免死迴圈等情況。</p><h2 id="智能合約能做什麼事？">智能合約能做什麼事？</h2><h3 id="創造新的加密代幣">創造新的加密代幣</h3><p>智能合約最基本的應用，就是做出新的加密代幣！只要<a href="https://theethereum.wiki/w/index.php/ERC20_Token_Standard" target="_blank" rel="noopener">遵循一定的規範</a>(ERC20)，部署一份智能合約到以太坊區塊鏈上，任何人都可以可以很容易地創造出自己的加密代幣。</p><p>不用像比特幣的山寨幣一樣需要自行徵募礦工。你的加密代幣會以&quot;以太坊的一個智能合約&quot;的形式存在於以太坊的區塊鏈中。現有支援以太幣的錢包與交易所，也可以快速地接入你的加密代幣。只要你發行的加密代幣與代幣背後所代表的服務具有交易的價值，代幣也可能變貨幣。</p><h3 id="募資">募資</h3><p>此外，在募資上，智能合約也有無與倫比的優勢。新創公司<a href="https://cointelegraph.com/news/the-ico-mania-and-its-consequences-on-ethereum" target="_blank" rel="noopener">ICO</a>可透過以太坊的智能合約，在收到資助者的以太幣時，自動發出等值的加密代幣。</p><p>由於這些加密代幣可交易，如果公司的服務有價值，早期投資人在投資的前期，就可以透過交易加密代幣來調整持有量。</p><p>普通的投資人也第一次有機會直接支持自己感興趣的創業者，並可能從而獲得豐厚(<a href="https://blog.gasolin.idv.tw/2017/08/12/things-to-know-before-join-ico/">或歸零</a>)的回報。</p><h3 id="程式能做的事">程式能做的事</h3><p>當你需要公開，可被信任的紀錄時，都可以透過智能合約達成。</p><h2 id="以太坊的缺點">以太坊的缺點</h2><p>目前以太坊區塊鏈的速度和電腦執行速度無法相比，不適合快速交易，或是需要儲存較大資料的情境。近期的<a href="http://www.investopedia.com/news/what-plasma-and-how-will-it-strengthen-ethereum-blockchain/" target="_blank" rel="noopener">plasma</a>提案有望解決快速交易的問題。</p><p>因為缺乏即時調控區塊大小的手段，在一些很熱門的交易時段(如某些熱門的ICO開放認購時)，整個網路的交易延遲會變地很長。</p><p>智能合約一經部署就永遠存在，除非擁有者啟動智能合約中的自毀(selfdestruct)功能。如何升級合約並保存其中的參數與代幣，是一個值得探討的課題。</p><p>以太坊網路節點上並不適合儲存較大的檔案。目前有<a href="https://github.com/ethersphere/swarm" target="_blank" rel="noopener">Swarm</a>與<a href="https://ipfs.io/" target="_blank" rel="noopener">IPFS</a>等分散式檔案儲存方式可供選擇。</p><h2 id="其他參考資料">其他參考資料</h2><ul><li>以太坊設計原理 <a href="http://ethfans.org/posts/510" target="_blank" rel="noopener">http://ethfans.org/posts/510</a></li><li>ethereum <a href="https://github.com/ethereum/wiki/wiki" target="_blank" rel="noopener">https://github.com/ethereum/wiki/wiki</a></li><li>挖礦教學 <a href="https://www.ptt.cc/bbs/DigiCurrency/M.1495624721.A.6A8.html" target="_blank" rel="noopener">https://www.ptt.cc/bbs/DigiCurrency/M.1495624721.A.6A8.html</a></li><li>以太坊、以太幣是什麼？ETH電腦挖礦圖文教程http://www.gooread.com/article/20122396003/</li><li><a href="https://github.com/vinsgo/awesome-ethereum" target="_blank" rel="noopener">https://github.com/vinsgo/awesome-ethereum</a></li><li>Ethereum Overview <a href="http://truffleframework.com/tutorials/ethereum-overview" target="_blank" rel="noopener">http://truffleframework.com/tutorials/ethereum-overview</a></li><li><a href="http://vitalik.ca/general/2017/09/14/prehistory.html" target="_blank" rel="noopener">A Prehistory of the Ethereum Protocol</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以太坊(Ethereum)是近幾年才發展起來的一種新的底層&lt;a href=&quot;https://blog.gasolin.idv.tw/2017/08/10/what-is-blockchain/&quot;&gt;區塊鏈&lt;/a&gt;技術。以太幣(Ether)是以太坊公有鏈上產生的🔒💵加密貨幣
      
    
    </summary>
    
    
      <category term="ethereum" scheme="https://blog.gasolin.idv.tw/tags/ethereum/"/>
    
      <category term="blockchain" scheme="https://blog.gasolin.idv.tw/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>收到我的ENS網域啦 gasolin.eth</title>
    <link href="https://blog.gasolin.idv.tw/2017/08/13/got-my-ens-domain/"/>
    <id>https://blog.gasolin.idv.tw/2017/08/13/got-my-ens-domain/</id>
    <published>2017-08-13T07:07:30.000Z</published>
    <updated>2018-03-31T08:09:13.246Z</updated>
    
    <content type="html"><![CDATA[<p>前幾天剛拿到<a href="https://etherscan.io/enslookup?q=gasolin.eth" target="_blank" rel="noopener">gasolin.eth</a>這個ENS網域。ENS (Ethereum Name Service)<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 的功能類似我們較熟悉的DNS(Domain Name Service)網域名稱服務，但提供的不是Internet網址，而是將以太坊(Ethereum)錢包地址和智能合約地址以<code>xxxxxxx.eth</code>網址的方式表示，可以用於轉帳或存取智能合約等地方。</p><h2 id="ens網域的應用情境">ENS網域的應用情境</h2><p>例如有人想轉錢給我，就可以請他將以太幣轉到<code>gasolin.eth</code>這網址，<code>gasolin.eth</code>會自動轉址到我指定的錢包地址(0x…)，轉帳的人不需要記憶一串根本像亂碼的以太幣錢包地址。</p><p><img src="http://i.imgur.com/nkbbryCl.png" alt="Imgur"></p><p>若我想要公開智能合約讓大眾使用，我可以公開諸如<code>service.gasolin.eth</code>這樣的網址，使用者只要連到<code>service.gasolin.eth</code>，就會自動轉到對應的智能合約地址。若這個智能合約所提供的是單次服務，我也可以透過修改<code>service.gasolin.eth</code>對應的智能合約地址，來&quot;升級&quot;這個智能合約服務。使用者依然是連到<code>service.gasolin.eth</code>使用這個服務，而不需要了解背後的機制。</p><h2 id="查詢可申請的網域">查詢可申請的網域</h2><p>因為<code>gasolin.eth</code>已經被我申請了，查詢可申請地址這部分將以搞笑的NMB(嫩模幣) ICO<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>為例，我會以申請<code>nenmocoin.eth</code>當做例子，介紹整個申請ENS網域的流程。</p><p>嫩模幣的投資條件是<code>本次投資僅接受ETH，最少投資額0.0.1ETH,ETH錢包地址:0x74b7bafafd200a58e79b719f3565cbb43af7d6b7</code>。如果能將<code>0x74b7bafafd200a58e79b719f3565cbb43af7d6b7</code>換成<code>nenmocoin.eth</code>，投資者轉帳起來就更直覺了。</p><p>在寫作時<code>nenmocoin</code>(<a href="https://registrar.ens.domains/#nenmocoin" target="_blank" rel="noopener">https://registrar.ens.domains/#nenmocoin</a>)這個網域是可以申請的(目前ENS僅接受申請7個字母以上的網域)。</p><p>想查詢可用的網域，可以前往　<a href="http://registrar.ens.domains/" target="_blank" rel="noopener">http://registrar.ens.domains/</a>　或連到<a href="https://www.myetherwallet.com/" target="_blank" rel="noopener">MyEtherWallet</a><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>並切換到<code>ENS</code>分頁，查詢可用的ENS網址。</p><p><img src="http://i.imgur.com/HIUcvyDl.png" alt="Imgur"></p><p>如果在一般瀏覽器中查看，會看到黃色欄的警告提示。</p><p><img src="http://i.imgur.com/I5rrWTHl.png" alt="Imgur"></p><p>這是因為ENS服務是跑在以太坊Ethereum區塊鏈上，要麼用專用的browser（如Mist），不然就是裝Parity，或瀏覽器擴充套件MetaMask(Chrome only)。還有個選擇就是用<a href="https://www.myetherwallet.com/" target="_blank" rel="noopener">MyEtherWallet</a>網頁錢包，裡面內建註冊ENS需要的功能。</p><p>我是使用<a href="https://www.myetherwallet.com/" target="_blank" rel="noopener">MyEtherWallet</a>網頁錢包來完成整個註冊gasolin.eth網域的流程。</p><h2 id="競標網域須知">競標網域須知</h2><ul><li>註冊ENS網域並不需要實名或其他認證流程，只要有一個以太幣錢包地址即可。</li><li>請參考<a href="https://blog.gasolin.idv.tw/2017/08/12/things-to-know-before-join-ico/">參與首次代幣發行(ICO)時要知道的事</a>，絕對不要用交易所提供的錢包競標網域，不然即使競標到網域也會變成交易所的XD。</li><li>ENS網域的最低起標價是0.01ETH(當前匯率是美金$2~3)</li></ul><p>要註冊ENS網域，需要遵循ENS網域競標流程(bid)。</p><p>ENS網域競標流程模擬現實的競標，首先是寫下標價，並將相應數量的以太幣傳入ENS票箱。兩天後就可以公告這個網域競標(揭標)，其他人能看到這個網域已經開始競標了。如果他們有興趣，也可以加入這個網域的競標。最終價高者得，但出價最高的人只需要繳交第二高者的標價。ENS會自動退回所有參與者的標金，也會返回得標者標金的差額。如果得標者一年後未續約，ENS將釋出此網域並退回押金。</p><div class="mermaid">  graph LR網域可註冊 --> 提出標金提出標金 -- 2 天 --> 公告競標公告競標 -- 2 天 --> 取得網域取得網域 -. 1 年後未續約 .-> 釋出網域並退回押金</div><h2 id="提出標金">提出標金</h2><p>確定&quot;nenmocoin&quot;網域可用，接下來就是打開錢包，開始競標吧。</p><p><img src="http://i.imgur.com/YEHuJWHl.png" alt="Imgur"></p><p>打開錢包，輸入超過最低起標價0.01ETH的數字，勇敢按下<code>Start an Auction</code>按鈕，並照著指示完成競標手續。</p><p>記得將畫面上的資料複製留存，後面的手續中會用到。完成競標手續後會進入2天的等待期。</p><h2 id="公告競標">公告競標</h2><p><img src="http://i.imgur.com/AaQPPa9.png" alt="Imgur"></p><p>其實照著<a href="https://www.myetherwallet.com/" target="_blank" rel="noopener">MyEtherWallet</a>上面的說明完成公告手續並不困難😤。最重要的事，就是在2天的等待期結束後，</p><p><strong>記得回來公告競標，</strong><strong>記得回來公告競標，</strong><strong>記得回來公告競標，</strong></p><p>如果沒做這個動作，前幾天提出的標金會被送到黑洞消失掉，沒辦法取回喔！我第一次試著註冊網域的時候就這樣被吃掉0.01ETH😭。</p><p>公告後其他人可以看到網域開始競標的訊息。這時有兩天的時間讓其他感興趣的人一起競標，當前最高價會顯示在查詢頁面上。</p><h2 id="取得網域">取得網域</h2><p>公告期結束後，如果順利取得網域，可以看到如下訊息</p><p><img src="http://i.imgur.com/hg9vHmo.png" alt="Imgur"></p><p>這時<strong>記得回來宣告取得網域，</strong><strong>記得回來宣告取得網域，</strong><strong>記得回來宣告取得網域，</strong></p><p>照著<a href="https://www.myetherwallet.com/" target="_blank" rel="noopener">MyEtherWallet</a>上面的說明完成宣告手續後，才能正式取得這個網域。</p><p>以後其他人查詢時，就會看到這個網域已經被註冊的訊息。</p><h2 id="取得網域之後">取得網域之後</h2><p>取得網域之後，在<a href="https://www.myetherwallet.com/" target="_blank" rel="noopener">MyEtherWallet</a>上查看網域並打開錢包，就會看到如何設定網域的說明。</p><p>目前設定網域的方式比較複雜些，需要到<code>Contracts</code>(合約)目錄下，在<code>Select Existing Contract</code>（選擇已經存在的合約）選擇<code>ENS - Public Resolver</code>，並在<code>Read/Write Contract</code>(讀取/寫入合約)部分選擇<code>setAddr</code>(設定地址)功能，照著設定網域說明將錢包地址輸入，這樣網域才能正確解析到我們想要的錢包地址。</p><p><img src="http://i.imgur.com/y6jvpAUl.png" alt="Imgur"></p><h2 id="如何節省交易手續費">如何節省交易手續費</h2><p>以上整套設定ENS的過程牽涉到5~6次交易。只有第一次需轉出標金，後面的各種動作都只收交易手續費。因此註冊一個ENS網域的成本其實是標金+多次手續費。標金在到期之後會返還，因此實際影響持有成本最大的是交易手續費。</p><p><a href="https://www.myetherwallet.com/" target="_blank" rel="noopener">MyEtherWallet</a>右上角預設的交易手續費是21GWei（1 Ether = 10^9 GWei）。手續費是給分礦工（提供計算力協助以太幣記帳的人）的，調低的話，交易確認的速度會變慢，調高則變快。我剛開始不懂，因此就使用了預設值。後來看Youtube上的教學，才知道可以參考<a href="http://ethgasstation.info/" target="_blank" rel="noopener">Gas Station</a>網站即時的<code>SafeLow Cost</code>（最低安全交易手續費）來設置。只要我們提供的手續費高於這個數目，交易都會成功。</p><p><img src="http://i.imgur.com/0loyakDl.png" alt="Imgur"></p><p>這陣子最低手續費大多是3 ~ 5 GWei。我照這個手續費做設定（並斟酌提高1 ~ 2 Gwei）交易都有成功。雖然不管用什麼標準來算，以太坊的手續費都已經很便宜，但多一步簡單的操作，就能感受到精打細算的樂趣。</p><h2 id="結語">結語</h2><p>上面舉了嫩模幣ICO的轉帳地址當做例子。<strong>我故意把引用的嫩模幣錢包地址，換成了我自己的錢包地址</strong>。如果不提，應該沒幾個人會注意到吧？如果錢包地址改用本文提到的<code>nenmocoin.eth</code>，參與者是不是更容易發現收款地址已被修改了呢？ENS並沒有做身分認證，釣魚網站也可以申請相似的ENS域名來釣魚，要避免這樣的情況，也有賴服務提供者有在提供服務前，有優先註冊域名的保護意識。</p><p>ENS本身其實就是一系列基於以太坊的智能合約<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>，內部的流程都是自動的，對於智能合約與DAPP開發者來說，也是很值得參考的架構。</p><h2 id="參考資料">參考資料</h2><ul><li>[1] Ethereum Name Service <a href="https://ens.domains/" target="_blank" rel="noopener">https://ens.domains/</a></li><li>[2] <a href="http://blockcast.it/2017/05/27/eth-and-eth-token-wallet-series-myetherwallet/" target="_blank" rel="noopener">Myetherwallet介紹</a></li><li>[3] 嫩模幣 <a href="http://nmb.fun/" target="_blank" rel="noopener">http://nmb.fun/</a></li><li>[4] ENS 原始碼　<a href="https://github.com/ethereum/ens" target="_blank" rel="noopener">https://github.com/ethereum/ens</a></li></ul><hr><p><a href="https://etherscan.io/enslookup?q=gasolin.eth" target="_blank" rel="noopener">gasolin.eth</a>這個網址真的可以用喔！覺得這篇文章寫得蠻好想打賞一下，可以傳到我的錢包地址<code>gasolin.eth</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前幾天剛拿到&lt;a href=&quot;https://etherscan.io/enslookup?q=gasolin.eth&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gasolin.eth&lt;/a&gt;這個ENS網域。ENS (Ethereum Name Ser
      
    
    </summary>
    
    
      <category term="ethereum" scheme="https://blog.gasolin.idv.tw/tags/ethereum/"/>
    
      <category term="ens" scheme="https://blog.gasolin.idv.tw/tags/ens/"/>
    
  </entry>
  
  <entry>
    <title>參與首次代幣發行(ICO)時要知道的事</title>
    <link href="https://blog.gasolin.idv.tw/2017/08/12/things-to-know-before-join-ico/"/>
    <id>https://blog.gasolin.idv.tw/2017/08/12/things-to-know-before-join-ico/</id>
    <published>2017-08-12T12:46:30.000Z</published>
    <updated>2018-03-31T08:09:13.246Z</updated>
    
    <content type="html"><![CDATA[<p>最近首次代幣發行(ICO)<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>相當熱門，但當代幣投資者打算贊助某個專案時，有相當多技術原因可能導致投資失敗，而這些原因大多是可以避免的。</p><h2 id="1-投資ico-新創-99-機率跟遇到詐騙沒兩樣">1.投資ICO/新創，99%機率跟遇到詐騙沒兩樣</h2><p>一般統計9成的新創會在一年內關門，存活下來的又有90%會在五年內倒閉。換句話說，新創的五年存活率只有1%。</p><p>首次代幣發行ICO的發起人多是新創公司，投資下去就跟投資新創一樣，有極大失敗的可能。如果不了解風險，沒做足夠的功課而盲目投資，99%機率投資ICO就跟遇到詐騙沒兩樣。就算發起人說得天花亂墜，到時參與ICO換得的代幣也只能當紀念用了。</p><h2 id="2-別用交易所錢包轉帳">2. 別用交易所錢包轉帳</h2><p><strong>交易所的錢包並不能換回其他代幣，</strong><strong>交易所的錢包並不能換回其他代幣，</strong><strong>交易所的錢包並不能換回其他代幣，</strong>重要的事說三遍。</p><p>交易所幾乎都會向客戶宣稱:開戶送比特幣/以太幣錢包。當客戶兌換好代幣後，客戶可以看到錢包帳戶裡的餘額，也可以轉進轉出，從客戶看來確實&quot;擁有&quot;了比特幣/以太幣錢包。</p><p>但是交易所的錢包畢竟是交易所的錢包。在轉出比特幣/以太幣時，交易所會動態選用自己轄下的某個錢包帳號出帳。你所參與的代幣眾籌，它的智能合約收到的是交易所的錢包帳號而不是你的錢包帳號，所以智能合約發代幣的對象也變成交易所了。</p><p>比較建議的方式是使用<a href="https://www.myetherwallet.com/" target="_blank" rel="noopener">MyEtherWallet</a><sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>或硬體錢包參與以太坊相關的ICO。其他可使用的錢包可查看參考資料<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>。</p><h2 id="3-用到假錢包">3. 用到假錢包</h2><p>無論是網路上或是手機應用程式商店中，有許多宣稱有比特幣/以太幣錢包功能的網站/App。其中依然有些是假錢包。當你使用這些錢包轉幣時，可能會被騙走。因此盡量選擇自己常用，有信譽的網站/應用，或硬體錢包來操作ICO。</p><p>網站應該加入書籤，以後都使用書籤中的網站存取。不要盲目信任搜尋引擎搜到的連結(原因在下一條)，或透過slack等社交網站，那些看起來像官方訊息提供的連結或地址[10]。</p><h2 id="4-轉帳時填錯地址或轉到假地址">4.轉帳時填錯地址或轉到假地址</h2><p>比特幣跟以太幣所謂的<code>錢包</code>地址，跟IPv6地址一樣，就是一串16進位數字(而且是頗長的一串。有人算過總共幾位數嗎?)。要投資時需要照著網站上提供的指示，將錢包地址複製到自己的錢包接收地址欄中。要是很不幸地複製錯了，你轉出的資金就被轉到不知是誰的錢包裡去了。由於以太坊上沒有銀行，一旦轉錯了，也沒有申訴的地方喔。</p><p>對於釣魚網站來說，這種根本就是亂碼的錢包地址真是個福音，因為只要將網站複製一下，錢包地址換成自己的，弄個前面網址一模一樣，但並非<code>.com</code>的假官方網域，再下個Google搜尋廣告，就可以開張來詐騙了!</p><p>但幸好最近ENS(Ethereum Name Service)<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> 地址網域開始投入使用，可以將以太坊(Ethereum)錢包地址以類似網址的方式表示。例如我(gasolin)若發起一個ICO，就可以請投資者將以太幣轉到<code>gasolin.eth</code>這網址。<code>gasolin.eth</code>會自動轉址到我指定的錢包地址。之後要公開智能合約讓大眾使用時，也可以公開諸如<code>service.gasolin.eth</code>這樣的網址，<code>service.gasolin.eth</code>會自動轉到對應的智能合約地址。</p><p><img src="http://i.imgur.com/nkbbryCm.png" alt="Imgur"></p><p>期望之後有更多的ICO和智能合約使用ENS，讓贊助者可以更安心地轉帳。</p><h2 id="5-代幣詐騙-scams">5.代幣詐騙(scams)</h2><p>隨著代幣眾籌愈發熱門，代幣詐騙(scams)也層出不窮。除了那種本來就是打算來詐騙(或是來搞笑<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>?)的專案之外，另一種可能的詐騙方式，是詐騙者做一個長得一模一樣的釣魚網站(phishing)，選一個與原來ICO網站類似的網址，並透過搜尋引擎或論壇散播。沒注意到的投資者就可能因此被騙去代幣。因此投資前務必多方確認。也可以到<code>cointelegraph</code><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>或<code>tokenmarket</code><sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>上查看近期的ICO列表。上面列出的ICO項目不代表可靠，但至少新聞網站為了信譽，會把明顯是詐騙的ICO剔除掉(?)。</p><h2 id="結語">結語</h2><p>投資一定有風險，ICO投資有賺有賠，申購前應詳閱公開說明書。可以將上面提到的幾點當作檢核表，避免因為技術原因導致投資失利。</p><p>雖然上面舉的gasolin ICO只是個例子，但 <a href="https://etherscan.io/enslookup?q=gasolin.eth" target="_blank" rel="noopener">gasolin.eth</a> 這個網址真的可以用喔！覺得這篇文章寫得蠻好想打賞一下，可以打賞一點ETH到我的錢包地址，順便試試ENS的功能:p之後也將分享如何註冊ETH地址的心得。</p><h2 id="參考資料">參考資料</h2><ul><li>[1] 首次公開發行加密代幣 <a href="https://zh.wikipedia.org/wiki/%E9%A6%96%E6%AC%A1%E4%BB%A3%E5%B8%81%E5%8F%91%E5%94%AE" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/首次代币发售</a></li><li>[2] 嫩模幣 <a href="http://nmb.fun/" target="_blank" rel="noopener">http://nmb.fun/</a></li><li>[3] <a href="https://cointelegraph.com/ico-calendar" target="_blank" rel="noopener">https://cointelegraph.com/ico-calendar</a></li><li>[4] <a href="https://registrar.ens.domains/" target="_blank" rel="noopener">https://registrar.ens.domains/</a></li><li>[5] <a href="http://blockcast.it/2017/05/27/eth-and-eth-token-wallet-series-myetherwallet/" target="_blank" rel="noopener">Myetherwallet介紹</a></li><li>[6] <a href="https://tokenmarket.net/ico-calendar" target="_blank" rel="noopener">https://tokenmarket.net/ico-calendar</a></li><li>[7] Token compatible Ethereum wallet list <a href="https://tokenmarket.net/what-is/ethereum-token-wallets/" target="_blank" rel="noopener">https://tokenmarket.net/what-is/ethereum-token-wallets/</a></li><li>[8] Protecting Yourself and Your Funds <a href="https://myetherwallet.github.io/knowledge-base/getting-started/protecting-yourself-and-your-funds.html" target="_blank" rel="noopener">https://myetherwallet.github.io/knowledge-base/getting-started/protecting-yourself-and-your-funds.html</a></li><li>[9] 如果你打算發行ICO，可以看看這篇介紹ICO過程中各種花式被駭的經驗 <a href="https://medium.com/@kickico/how-they-tried-to-hack-our-ico-d348659dc4" target="_blank" rel="noopener">https://medium.com/@kickico/how-they-tried-to-hack-our-ico-d348659dc4</a></li><li>[10] How to scam Ethereum in 24 hrs with Slack <a href="https://hackernoon.com/how-to-scam-102-860-usd-worth-of-ethereum-in-24-hrs-with-slack-63ce1032219c" target="_blank" rel="noopener">https://hackernoon.com/how-to-scam-102-860-usd-worth-of-ethereum-in-24-hrs-with-slack-63ce1032219c</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近首次代幣發行(ICO)&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;相當熱門，但當代幣投資者打算贊助某個專案時，有相當多技術原因可能導致投資失敗，而這些原因大多是可以避免的。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
      <category term="ethereum" scheme="https://blog.gasolin.idv.tw/tags/ethereum/"/>
    
      <category term="ico" scheme="https://blog.gasolin.idv.tw/tags/ico/"/>
    
  </entry>
  
  <entry>
    <title>區塊鏈是什麼？</title>
    <link href="https://blog.gasolin.idv.tw/2017/08/10/what-is-blockchain/"/>
    <id>https://blog.gasolin.idv.tw/2017/08/10/what-is-blockchain/</id>
    <published>2017-08-10T14:23:31.000Z</published>
    <updated>2018-03-31T08:09:13.246Z</updated>
    
    <content type="html"><![CDATA[<p>今年比特幣(Bitcoin)<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>與以太幣(Ether)<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>價格紛紛到達新高。主因除了隨著更多支援加密貨幣(Crypto Currency)-當地貨幣的兌換/代購/交易所開張，取得虛擬貨幣/代幣的方式更加多元外，首次公開發行加密代幣(ICO, Initial Coin/Crypto Token Offering)<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> 這種創新的投資/募資方式愈加熱絡，也讓一些個人與機構意識到虛擬貨幣作為貨幣或貨品的投資價值。</p><p>這些虛擬幣背後所使用的技術叫做區塊鏈(blockchain)<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>，可以被用來解決各種「交易」相關的問題。</p><h2 id="網際網路交換訊息-區塊鏈交換價值">網際網路交換訊息，區塊鏈交換價值</h2><p>網際網路出現之前，不同的系統之間沒辦法用標準的協定來互相通訊和傳遞訊息。網際網路讓不同連網方式（撥接、光纖、4G）、不同設備間可以互相連接，滿足人與人之間對訊息的即時需求。人們的生活在網際網路發展起來的這20多年間，也因此產生了極大地改變。</p><p>2001年時，Napter<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>開啟了透過點對點(P2P)網路交換MP3的風潮，這是第一次大眾意識到點對點網路可以被廣泛地應用在資訊交換上。隨後BitTorrent(BT)<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>接過大旗，透過BitTorrent與配合的磁力連結(Magnet Link)<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>，2009年時已占據了近50%整體網際網路流量。</p><p>區塊鏈基於網際網路，點對點(P2P)網路，和以密碼學為基礎的共識紀錄機制，提供了一個可以不被地域限制，快速交換價值的方式，降低交易的不確定性(uncertainty)與風險。網際網路和點對點網路解決了資訊交換的問題，而區塊鏈則進一步想解決價值交換與交易信任的問題。</p><div class="mermaid">  graph TD公開加密貨幣 --- 區塊鏈公開加密貨幣 --- 激勵機制區塊鏈 --- P2P區塊鏈 --- 共識機制共識機制 --- 密碼學P2P --- 網際網路</div><p>區塊鏈不僅只是加密貨幣，透過區塊鏈，我們可以和各地的人做生意，用很低的手續費在不同國家收款與匯款(都在同一個公開區塊鏈上)，而且幾分鐘內就可到帳；交易的過程中，所有的合約都由網路上的節點自動執行(智能合約 Smart Contract)，可以避免人為操縱與詐欺等潛在的信任問題，讓人們可以更安心地交易；未來還可以透過瀏覽器使用智能合約，就像使用網站一樣容易(分散式應用 DAPP)。</p><p>暢想未來的商業模型，可能是顧客透過易用的手機或網頁DAPP取得商家提供的資訊，經由可信任的智能合約，讓彼此能快速地交換價值與服務。</p><h2 id="聯盟鏈">聯盟鏈</h2><p>區塊鏈根據型態，大致分為公有鏈，私有鏈、聯盟鏈幾種。公有鏈就是大眾比較常聽到的各種加密代幣。可以在 <a href="https://coinmarketcap.com/" target="_blank" rel="noopener">https://coinmarketcap.com/</a> 查看大部分的加密貨幣。除了公有鏈之外，多家銀行、支付機構、甚至IBM、微軟等科技公司也相繼投入資源，參與區塊鏈研究與發展。多數機構採用的是聯盟鏈的形式。Apache基金會下的Hyper Ledger<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>計畫是目前發展較好的聯盟鏈。</p><p>聯盟鏈與公有鏈有許多不同點。其一是對資料一致性有更高地要求。其二因為相對來說聯盟鏈的節點比較可控，也不需要加入代幣激勵機制或浪費能源在比拚算力的Prove-of-WOrk(PoW)共識機制上。其三是需要對資源與智能合約存取設置權限，以符合企業內部的需求。</p><h2 id="區塊鏈用到的加密技術">區塊鏈用到的加密技術</h2><p>可以在Youtube上查看 <a href="https://youtu.be/_160oMzblY8" target="_blank" rel="noopener">Blockchain 101 - A Visual Demo</a>影片<sup id="fnref:14"><a href="#fn:14" rel="footnote">14</a></sup>，或前往對應的<a href="https://anders.com/blockchain/" target="_blank" rel="noopener">Block Chain Demo網站</a><sup id="fnref:15"><a href="#fn:15" rel="footnote">15</a></sup>自行動手試驗。</p><h2 id="參考資料">參考資料</h2><ul><li>[1] 比特幣 <a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E7%89%B9%E5%B8%81" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/比特币</a></li><li>[2] 以太坊 <a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E5%9D%8A" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/以太坊</a></li><li>[3] 首次公開發行加密代幣 <a href="https://zh.wikipedia.org/wiki/%E9%A6%96%E6%AC%A1%E4%BB%A3%E5%B8%81%E5%8F%91%E5%94%AE" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/首次代币发售</a></li><li>[4] 區塊鏈https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9D%97%E9%93%BE</li><li>[5] Napster <a href="https://en.wikipedia.org/wiki/Napster" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Napster</a></li><li>[6] BitTorrent <a href="https://en.wikipedia.org/wiki/BitTorrent" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/BitTorrent</a></li><li>[7] 磁力連結 <a href="https://zh.wikipedia.org/wiki/%E7%A3%81%E5%8A%9B%E9%93%BE%E6%8E%A5" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/磁力链接</a></li><li>[8] <a href="http://lifehacker.com/5875899/what-are-magnet-links-and-how-do-i-use-them-to-download-torrents" target="_blank" rel="noopener">What Are Magnet Links, and How Do I Use Them to Download Torrents?</a></li><li>[9] <a href="https://www.hyperledger.org/" target="_blank" rel="noopener">https://www.hyperledger.org/</a></li><li>[10] <a href="https://entethalliance.org/" target="_blank" rel="noopener">https://entethalliance.org/</a></li><li>[11] <a href="https://en.wikipedia.org/wiki/Proof-of-work_system" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Proof-of-work_system</a></li><li>[12] How Bitcoin Works Under the Hood <a href="https://www.youtube.com/watch?v=Lx9zgZCMqXE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Lx9zgZCMqXE</a></li><li>[13] TED <a href="https://www.youtube.com/watch?v=RplnSVTzvnU" target="_blank" rel="noopener">How the blockchain will radically transform the economy</a></li><li>[14] <a href="https://youtu.be/_160oMzblY8" target="_blank" rel="noopener">Blockchain 101 - A Visual Demo</a></li><li>[15] <a href="https://anders.com/blockchain/" target="_blank" rel="noopener">Block Chain Demo網站</a></li><li>[16] What is an Initial Coin Offering? <a href="https://www.youtube.com/watch?v=iyuZ_bCQeIE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=iyuZ_bCQeIE</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今年比特幣(Bitcoin)&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;與以太幣(Ether)&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/
      
    
    </summary>
    
    
      <category term="ethereum" scheme="https://blog.gasolin.idv.tw/tags/ethereum/"/>
    
      <category term="blockchain" scheme="https://blog.gasolin.idv.tw/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>Electron 是什麼</title>
    <link href="https://blog.gasolin.idv.tw/2017/08/09/what-is-electron/"/>
    <id>https://blog.gasolin.idv.tw/2017/08/09/what-is-electron/</id>
    <published>2017-08-09T09:31:34.000Z</published>
    <updated>2018-03-31T08:09:13.250Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://electron.atom.io/" target="_blank" rel="noopener">Electron</a>是一套結合了Chromium瀏覽器與Node.js功能，能使用網頁相關技術撰寫桌面應用的框架。</p><div class="mermaid">  graph LRNode --> ElectronChromium --> Electron</div><p>Electron 除了使用網頁當作應用程式介面，像一般桌面應用一樣離線可使用之外，開發者可以使用npm上的各種node module來加快開發速度。</p><p>諸如存取檔案，標題列（Task bar），桌面圖示（Dock icons），系統通知（Notification），選單，快捷鍵等作業系統的原生功能，Electron 也都有支援，可以用來製作大部分的應用程式。</p><p>目前許多人使用的<a href="https://atom.io/" target="_blank" rel="noopener">atom</a>與<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a>編輯器，都是基於Electron製作的。事實上Electron就是Github在開發atom編輯器的過程中產生的專案。</p><h2 id="使用electron">使用Electron</h2><p>安裝Electron已經變得相當簡單</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ electron-prebuilt</span><br></pre></td></tr></table></figure><p>使用以下命令執行</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">electron .</span><br></pre></td></tr></table></figure><p>或是直接下載官方提供的<a href="https://github.com/electron/electron-quick-start" target="_blank" rel="noopener">electron-quick-start</a>樣板來開始使用。</p><h2 id="electron-的問題">Electron 的問題</h2><p>Electron 對網頁開發人員來說相當友好，但封裝後檔案較大。使用者介面由於是使用網頁技術製作，往往和系統原生介面不一致，在選擇時要注意。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://electron.atom.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Electron&lt;/a&gt;是一套結合了Chromium瀏覽器與Node.js功能，能使用網頁相關技術撰寫桌面應用的框架。&lt;/p&gt;
&lt;div c
      
    
    </summary>
    
    
      <category term="web" scheme="https://blog.gasolin.idv.tw/tags/web/"/>
    
      <category term="desktop" scheme="https://blog.gasolin.idv.tw/tags/desktop/"/>
    
  </entry>
  
  <entry>
    <title>如何使用ES6+</title>
    <link href="https://blog.gasolin.idv.tw/2017/07/31/howto-use-es6plus/"/>
    <id>https://blog.gasolin.idv.tw/2017/07/31/howto-use-es6plus/</id>
    <published>2017-07-31T08:30:31.000Z</published>
    <updated>2018-03-31T08:09:13.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="es6-是什麼？">ES6+是什麼？</h2><p>近幾年有關注Javascript或Web領域的話，應該會聽過”ES6“這個頗熱門的詞彙。</p><p>ES6代表的是ECMAscript<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>第六版規則。ECMA是一個國際標準組織，各家相關廠商在ECMA-262標準中，定義了 ECMAscript 這個 Javascript 語言的參考標準。</p><p>從2011年起，Javascript語言已停滯在5.1版多年，直到在2015年時釋出了ES6，補足了諸多語言本身的許多特性，讓Javascript更便於使用。</p><p>從ES6開始，ECMAScript將每年將固定釋出新版本。因此 ES6 也可稱為 ES2015。目前已有ES2015，ES2016，ES2017多個新版本，這批新特性被統稱為ES6+或ES2015+。</p><p>之所以到了2017年還有許多人依然在講ES6，是因為ES6為Javascript帶來了20多項較大的語法改動，與之前開發者所認識的Javascript有了很大的不同。</p><h2 id="怎麼使用-es6">怎麼使用 ES6+</h2><p>最新版的主流瀏覽器Chrome、Firefox，或是Node.js 8.0.0以上版本都已實作ES2015~ES2017的所有功能。</p><p>如果想要使用最新的功能，同時又希望能相容其他瀏覽器或舊版的Node，可以使用Babel<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>來達成。Babel是當前最通用的javascript語言轉譯器(Transpiler)，它可以接受使用新語法撰寫的Javascript程式，並將這份程式轉換成與舊版語法相容的Javascript程式。</p><p>實際使用babel時，不需要手動設定ES2015~各年份的preset，只要安裝Env preset<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup>並在<code>package.json</code>中做以下設定：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;env&quot;, &#123;</span><br><span class="line">      &quot;targets&quot;: &#123;</span><br><span class="line">        &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;safari &gt;= 7&quot;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;node&quot;: &quot;current&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>babel 就會根據近期的瀏覽器支援與你所使用的Node版本，自動引入所有需要的plugin，相當方便。</p><h2 id="es6-有什麼新功能">ES6+有什麼新功能?</h2><p>想要大致了解各種語法上的改動，可以查看babel的 es2015<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>, es2016<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>, es2017<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> preset。每個preset中包含了各種相關語法的plugin。</p><p>例如今年的preset(es2017) ，帶來了 trailing-function-commas<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup> 和 async<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup> 語法的支援。</p><h2 id="參考資料">參考資料</h2><ul><li>[1] <a href="https://en.wikipedia.org/wiki/ECMAScript" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/ECMAScript</a></li><li>[2] <a href="https://babeljs.io/" target="_blank" rel="noopener">https://babeljs.io/</a></li><li>[3] <a href="https://babeljs.io/docs/plugins/preset-es2015/" target="_blank" rel="noopener">https://babeljs.io/docs/plugins/preset-es2015/</a></li><li>[4] <a href="https://babeljs.io/docs/plugins/preset-es2016/" target="_blank" rel="noopener">https://babeljs.io/docs/plugins/preset-es2016/</a></li><li>[5] <a href="https://babeljs.io/docs/plugins/preset-es2017/" target="_blank" rel="noopener">https://babeljs.io/docs/plugins/preset-es2017/</a></li><li>[6] <a href="https://babeljs.io/docs/plugins/syntax-trailing-function-commas/" target="_blank" rel="noopener">https://babeljs.io/docs/plugins/syntax-trailing-function-commas/</a></li><li>[7] <a href="https://babeljs.io/docs/plugins/transform-async-to-generator/" target="_blank" rel="noopener">https://babeljs.io/docs/plugins/transform-async-to-generator/</a></li><li>[8] <a href="https://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="noopener">https://babeljs.io/docs/plugins/preset-env/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;es6-是什麼？&quot;&gt;ES6+是什麼？&lt;/h2&gt;
&lt;p&gt;近幾年有關注Javascript或Web領域的話，應該會聽過”ES6“這個頗熱門的詞彙。&lt;/p&gt;
&lt;p&gt;ES6代表的是ECMAscript&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; re
      
    
    </summary>
    
    
      <category term="web" scheme="https://blog.gasolin.idv.tw/tags/web/"/>
    
      <category term="node" scheme="https://blog.gasolin.idv.tw/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 的發展</title>
    <link href="https://blog.gasolin.idv.tw/2017/07/21/how-node-works/"/>
    <id>https://blog.gasolin.idv.tw/2017/07/21/how-node-works/</id>
    <published>2017-07-21T09:54:18.000Z</published>
    <updated>2018-03-31T08:09:13.246Z</updated>
    
    <content type="html"><![CDATA[<p>2009年推出的Node.js<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>是讓Javascript成為一門廣為通用的程式語言的關鍵。Node.js將原專為Chrome<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>瀏覽器開發的V8引擎抽離出瀏覽器，讓使用者在一般命令行環境中就可以執行Javascript。</p><h2 id="開發者的需求">開發者的需求</h2><p>要完成一個全功能的現代網站，開發者除了需要至少理解某門語言相關的網站後端技術之外，Javascript也是身在Web開發領域的開發者至少必須&quot;略懂&quot;的腳本程式語言(scripting language)。</p><p>既然不管精通哪門程式語言的開發者，想在瀏覽器上發揮，都仍需要某種程度地熟悉Javascript程式語言。那麼，如果在瀏覽器之外，也可以拿Javascript來做事情不是很好嗎?</p><h2 id="node-js">Node.js</h2><p>Node.js並不是第一款讓使用者在一般命令行環境中就可以執行Javascript的工具(最早推出的可能是Mozilla的Rhino或XULRunner<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>)，但它跟上了潮流。2008年推出的Chrome瀏覽器，裡面使用了同被KDE與Apple使用的Webkit作為渲染引擎(Render)，並自行開發了全新的Javascript引擎(V8引擎)。Chrome瀏覽器的V8引擎率先支援JIT(Just in Time)編譯技術，使得當年Javascript的執行效率一舉提升了8倍以上📈。基於V8引擎的Node.js也比其他Javascript運行環境有更強的競爭力。由於執行速度的改善，Javascript語言終於有了和其他程式語言在瀏覽器之外的環境同場競技的實力。</p><h2 id="node-js的好夥伴-npm">Node.js的好夥伴: NPM</h2><p>Node.js推出當時，除了擁有一個比其他相似競爭者快上幾倍的引擎之外，在隔年整合的NPM(Node Package Manager)<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>套件管理工具，讓Javascript開發者擁有了更有效率地分享與重用函式庫的方式。到了今天，下載大多數使用Javascript語言撰寫的專案，只要執行<code>npm install</code>(或衍生的<code>yarn install</code>)，NPM就能自行安裝與解決套件之間的依賴關係。NPM實是今日Node.js之所以能形成圍繞著Javascript語言建立起龐大生態系的不可或缺的功臣。</p><h2 id="node-js衍生發展">Node.js衍生發展</h2><p>隨著Node.js更加成熟，Web開發者也圍繞著Node.js重新發明他們常用的工具。最先是Web開發框架（如Express.js<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>, hapi, koa）與資料庫接口，再來是相關的編譯工具（grunt, gulp, webpack<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>）。同時，也有人開始嘗試將Node.js與原有的瀏覽器環境結合，讓開發者得以使用網頁相關技術打造桌面應用（nw.js, electron<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>)。基於此技術還發展了數個流行的程式編輯器（atom, Visual Studio Code<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup>）。時至今日，也可透過Node.js相關編譯工具，使用網頁相關技術來做行動裝置App開發（Cordova, React Native<sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup>）。圍繞著Node.js的種種發明，讓使用網頁技術的開發者，得以從開發到部署，全都在圍繞網頁技術的生態系中完成。並由此誕生了稱之為 “Full Stack” 全端工程師（前端，後端，整合，測試）和大前端工程師的工作。全端工程師除了需處理網頁端（前端）頁面版型與互動效果外，也要兼顧伺服器端（後端）與資料庫處理。大前端工程師則是除了網頁端之外，也須兼顧行動裝置App的開發。</p><div class="mermaid">  graph LRJavascript --> BrowserJavascript --> NodeNode --> Webframework[Web Framework]Node --> Build[Build tools]Build --> ReactNative[Mobile App]Node --> Electron[Desktop App]Electron --> Editor[Editor]Browser --> Electron</div><h2 id="參考資料">參考資料</h2><ul><li><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> <a href="https://en.wikipedia.org/wiki/Node.js" target="_blank" rel="noopener">Node.js</a></li><li><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> <a href="https://en.wikipedia.org/wiki/Google_Chrome" target="_blank" rel="noopener">Google Chrome</a></li><li><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> <a href="https://en.wikipedia.org/wiki/XULRunner" target="_blank" rel="noopener">XULRunner</a></li><li><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> <a href="https://en.wikipedia.org/wiki/Npm_(software)" target="_blank" rel="noopener">NPM</a></li><li><sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> <a href="https://expressjs.com/" target="_blank" rel="noopener">Express.js</a></li><li><sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup> <a href="https://webpack.github.io/" target="_blank" rel="noopener">webpack</a></li><li><sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup> <a href="https://electron.atom.io/" target="_blank" rel="noopener">Electron</a></li><li><sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a></li><li><sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup> <a href="https://facebook.github.io/react-native/" target="_blank" rel="noopener">React Native</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2009年推出的Node.js&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;是讓Javascript成為一門廣為通用的程式語言的關鍵。Node.js將原專為Chrome&lt;sup id=&quot;fnref:2
      
    
    </summary>
    
    
      <category term="web" scheme="https://blog.gasolin.idv.tw/tags/web/"/>
    
      <category term="mobile" scheme="https://blog.gasolin.idv.tw/tags/mobile/"/>
    
  </entry>
  
  <entry>
    <title>Current Progress of Netmonitor.html</title>
    <link href="https://blog.gasolin.idv.tw/2017/03/28/current-progress-of-netmonitor-html/"/>
    <id>https://blog.gasolin.idv.tw/2017/03/28/current-progress-of-netmonitor-html/</id>
    <published>2017-03-28T16:33:37.000Z</published>
    <updated>2018-03-31T08:09:13.242Z</updated>
    
    <content type="html"><![CDATA[<p>Update: Full instructions are avaiable on <a href="https://github.com/mozilla/gecko-dev/blob/master/devtools/client/netmonitor/README.md" target="_blank" rel="noopener">Netmonitor Readme</a> to run the Network Monitor in the browser tab.</p><p>Firefox Devtools is in progress of modernizing its infrastructure to use the same toolset that modern web developers are familiar with. When talking about <code>modern</code> web developers toolset, I mean <code>React</code>, <code>Redux</code>, <code>Immutablejs</code>, and <code>npm</code> modules.😎</p><h2 id="what-firefox-devtools-team-did-last-year">What Firefox Devtools team did last year</h2><p>Firefox Devtools was no different from Firefox itself. The Devtools panels are written in <code>XUL</code>, an HTML-like syntax language, and use several Firefox internal API called <code>XPCOM</code> or <code>Chrome privileged API</code>(Nothing related to Chrome Browser) to make the browser works.👽</p><p>In last year(2016), Firefox Devtools team’s main goal is to convert the code base from XUL to pure HTML. The second goal is convert each tool with React/Redux structure for maintenance. Debugger, Inspector, Web Console are the first batch in the conversion progress.<a href="https://hacks.mozilla.org/2016/09/introducing-debugger-html/" target="_blank" rel="noopener">Debugger.html</a> is the very first attempt from Firefox Devtools team to embrace the modern web developers’ toolset. Now new Debugger and Web Console are available in Firefox <a href="https://www.mozilla.org/en-US/firefox/channel/desktop/" target="_blank" rel="noopener">Nightly</a>🍸</p><p><a href="https://github.com/devtools-html/debugger.html" target="_blank" rel="noopener">Debugger.html</a>, <a href="">Perf.html</a>(Performance) has their standalone repository hosted on Github. A developer could use <code>git clone</code> to get the repository, and then do <code>yarn install</code>, <code>yarn start</code>(similar to npm command) to debug the debugger.html/perf.html with any browser’s devtools!🚅</p><div class="mermaid">  graph LRclone[git clone] --> install[yarn install]install --> start[yarn start]</div><h2 id="what-run-on-the-browser-tab-means">What <code>Run on the Browser tab</code> means?</h2><p><code>Run on the Browser tab</code> is a term versus <code>Run inside of the developer panel</code>. Traditionally Devtools are running inside of the browser’s developer panel. But some of new Firefox Devtools support run as normal web pages. Those pages can be opened in a browser tab by any modern browser such as Chrome, Safari, or Edge. The benefit is we can improve Firefox Devtools with any Browser’s Devtools, its an unfair advantage.🚀</p><div class="mermaid">  graph LRFirefox -- debugging --> netmonitor(Netmonitor.html)netmonitor -- mozilla-rdp --> FirefoxChrome -- debugging --> netmonitorEdge -- debugging --> netmonitorSafari -- debugging --> netmonitor</div><p>We are going to make more Devtools easy to debug and can be used for cross-browser debugging.</p><h2 id="current-status">Current Status</h2><p>To replacing the jet engine while still flying is a challenging engineering work. To make it happen, we take several engineering experiments around Devtools.</p><p>Here are the projects in progress and where they are hosted from:</p><div class="mermaid">  graph LRdebugger(Debugger.html) --> Nightlyperf(Perf.html) --> Nightlywebconsole(WebConsole.html) --> Nightlystandalone[Github] --> debuggerstandalone --> perfrefactor[mozilla-central] --> webconsoleinspector(Inspector.html) --> Releasenetmonitor(Netmonitor.html) --> Releaserefactor --> inspectorrefactor --> netmonitor</div><h2 id="what-we-have-done-in-netmonitor-html">What we have done in Netmonitor.html</h2><p>Ricky Chien and I joined the effort of convert Object Inspector from XUL to HTML. Object Inspector is a more complicated tool to convert, so Object Inspector is still half <code>React</code> and without <code>Redux</code> in the playground.</p><p>When the Object Inspector is fully converted to HTML, we shift our focus on convert the next important Devtool: <code>Netmonitor</code>. With Honza, Janda, Steve Chung, and other contributors’ help, at the end of Feb we have reached our first phase tangible goal: Converted the whole Netmonitor panel from XUL to HTML, with <code>React</code>, <code>Redux</code>, and <code>Immutablejs</code>. Now we have confidence that the code base is easy to read and contribute.🤗</p><p><img src="http://i.imgur.com/aiqBXV5.png" alt="Imgur">Picture: How current Netmonitor looks like</p><h2 id="what-we-plan-to-do-next">What we plan to do next</h2><p>We just finished the Netmonitor workweek (Fred, Honza, Ricky) in Taiwan, plenty of discussions have occurred, and we have good progress for what should be going on for the Netmonitor.</p><p>Here they are:</p><ul><li>We’ve triaged all new Netmonitor bugs and identify <a href="http://firefox-dev.tools/?easy&amp;tool=network" target="_blank" rel="noopener">good-first-bugs</a></li><li>We have Prove-Of-Concept branches to prove we can run netmonitor on the browser tab</li><li>We decide to keep using <code>mozilla-central</code>(The gecko) repo. Beside the current workflow, a developer would able to run <code>yarn start</code> command to debugging Netmonitor on the browser tab with any browser’s devtool.</li><li>We stop Netmonitor.html phase I work immediately (convert XUL to HTML, MVP 100% completed)</li><li>We’ll start Netmonitor.html phase II (To run Netmonitor on a browser tab so that we can debug Netmonitor with any browser’s devtool)<ul><li>All phase II bugs are filed in the <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1348737" target="_blank" rel="noopener">Meta-bug</a></li></ul></li></ul><h2 id="what-could-expect-in-the-future">What could expect in the future</h2><p>Currently, Debugger.html have supported both Firefox and Chrome remote debugging protocols, so Debugger.html could be used to debug Firefox, Chrome, or even Node.js!😮</p><div class="mermaid">  graph LRFirefox -- debugging --> netmonitor(Netmonitor.html)netmonitor -- mozilla-rdp --> FirefoxChrome -- debugging --> netmonitornetmonitor -- chrome-rdp --> Chromenetmonitor -- chrome-rdp --> Node[Node.js]Safari -- debugging --> netmonitorEdge -- debugging --> netmonitor</div><p>Since Debugger.html’s pure web stack nature, you can imagine one day the debugger.html can be embedded into some editors(Atom, Visual Studio Code) as plugins, or even in other browsers!😇</p><div class="mermaid">  graph LRdebugger(Debugger.html) --> Firefoxdebugger --> browsertab[Browser Tab]debugger --> Editordebugger --> other[Other Browser]</div><p><code>Run with different remote debugging protocols</code> is the next step once we make Netmonitor.html run on the browser tab.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Update: Full instructions are avaiable on &lt;a href=&quot;https://github.com/mozilla/gecko-dev/blob/master/devtools/client/netmonitor/README.md&quot;
      
    
    </summary>
    
    
      <category term="web" scheme="https://blog.gasolin.idv.tw/tags/web/"/>
    
      <category term="devtools" scheme="https://blog.gasolin.idv.tw/tags/devtools/"/>
    
  </entry>
  
  <entry>
    <title>如何修改 git commits</title>
    <link href="https://blog.gasolin.idv.tw/2017/03/13/git-merge-commits/"/>
    <id>https://blog.gasolin.idv.tw/2017/03/13/git-merge-commits/</id>
    <published>2017-03-13T10:16:20.000Z</published>
    <updated>2018-03-31T08:09:13.242Z</updated>
    
    <content type="html"><![CDATA[<p>與其他人合作🤝使用git版本控制系統時，為了讓最後合併（Merge）的commit好看，常常會需要調整自己的commit。</p><h2 id="同時修改一個commit">同時修改一個commit</h2><p>剛開始工作時一次只修改一個commit，最常用到的命令是：</p><h3 id="修改commit訊息-message">修改commit訊息(message)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>在commit後加入<code>--amend</code>(修正)參數，可以修改最後一個commit的訊息。</p><h3 id="將後續修改合併成一個commit">將後續修改合併成一個commit</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure><p>將要合併的commit從<strong>pick</strong>改成<strong>s</strong>(squish)後儲存，修改commit訊息後，可以得到剩下的一個commit。</p><h2 id="同時修改多個commit">同時修改多個commit</h2><p>到後來為了讓審查(Review)更容易,漸漸開始嘗試在遇到某些較複雜的問題時，在同一個Branch堆疊多個commit的開發方式。</p><p>假設手上有3個疊在一起的commit(commit 1,commit 2,commit 3. commit 3是最新的commit), 這時在修改的過程中會遇到的主要問題，就是現在的修改與最新的commit(commit 3)無關, 但與最前面的commit(commit 1)相關。這時若想要將現在的修改與之前的commit 1合併，原本常使用的<code>git rebase</code>就不是那麼好用了。</p><h3 id="為前面commit的打補釘">為前面commit的打補釘</h3><p>要為前面commit的打補釘，可以使用命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --fixup &lt;commit&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;commmit&gt;</code>代表之前commit(commit 1)的hash。輸入後最新的commit中會出現<code>fixup &lt;commit 1&gt;</code>的註記。</p><h3 id="合併所有的補釘">合併所有的補釘</h3><p>當一系列修改完成後，只要使用命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i --autosquash</span><br></pre></td></tr></table></figure><p>儲存後可以得到干淨的commit 1,2,3🤘</p><h3 id="修改任何之前的commit訊息">修改任何之前的commit訊息</h3><p>如果只想修改之前的commit訊息，可以用命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure><p>將<strong>pick</strong>改成<strong>reword</strong>，儲存後就可以修改訊息。</p><h2 id="參考資料">參考資料</h2><ul><li><a href="http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html" target="_blank" rel="noopener">GIT tip : Keep your branch clean with fixup and autosquash</a></li><li><a href="https://inteist.com/ammend-or-change-previous-git-commit-message/" target="_blank" rel="noopener">Ammend/Change Previous Git Commit Message</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;與其他人合作🤝使用git版本控制系統時，為了讓最後合併（Merge）的commit好看，常常會需要調整自己的commit。&lt;/p&gt;
&lt;h2 id=&quot;同時修改一個commit&quot;&gt;同時修改一個commit&lt;/h2&gt;
&lt;p&gt;剛開始工作時一次只修改一個commit，最常用到的命令
      
    
    </summary>
    
    
      <category term="git" scheme="https://blog.gasolin.idv.tw/tags/git/"/>
    
      <category term="work" scheme="https://blog.gasolin.idv.tw/tags/work/"/>
    
  </entry>
  
</feed>
